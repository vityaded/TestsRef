{% extends "layouts/base.html" %}

{% set total_pages = activity.pages|length %}
{% set is_last_page = page.page_number >= total_pages %}

{% block title %}{{ activity.title }} - Page {{ page.page_number }}{% endblock %}

{% block content %}
<div class="reading-view">
  <div class="row">
    <div class="col-lg-8">
      <div class="card reading-card mb-4">
        <div class="card-body">
          <div class="reading-header">
            <div>
              <h1 class="reading-title mb-1">{{ activity.title }}</h1>
              <p class="reading-subtitle mb-0 text-muted">Page {{ page.page_number }} of {{ total_pages }}</p>
            </div>
            <span id="recognition-status" class="badge badge-secondary">Idle</span>
          </div>

          <div class="mt-4">
            <div class="progress reading-progress" role="progressbar" aria-label="Reading progress" aria-valuemin="0" aria-valuemax="100">
              <div class="progress-bar" id="word-progress-bar" style="width: 0%;" aria-valuenow="0"></div>
            </div>
            <div class="d-flex justify-content-between align-items-center mt-2 text-muted small">
              <span id="word-progress-text">0 / {{ page.content.split()|length }} words</span>
              <span id="page-progress-text">Press start to begin</span>
            </div>
          </div>

          <div class="reading-controls mt-4">
            <div class="btn-toolbar flex-wrap" role="toolbar" aria-label="Reading controls">
              <div class="btn-group mr-2 mb-2" role="group" aria-label="Recognition controls">
                <button type="button" class="btn btn-primary" id="start-btn">Start reading</button>
                <button type="button" class="btn btn-outline-secondary" id="stop-btn" disabled>Pause</button>
              </div>
              <div class="btn-group mr-2 mb-2" role="group" aria-label="Assistance controls">
                <button type="button" class="btn btn-outline-info" id="repeat-btn" disabled>üîä Hear word</button>
                <button type="button" class="btn btn-outline-warning" id="skip-btn" disabled>Skip word</button>
                <button type="button" class="btn btn-outline-secondary" id="restart-btn" disabled>Restart page</button>
              </div>
              <div class="reading-font-control mb-2">
                <label for="font-size-control" class="mr-2 mb-0 text-muted small">Text size</label>
                <input type="range" id="font-size-control" class="custom-range" min="16" max="30" value="20" aria-label="Text size">
                <span id="font-size-value" class="ml-2 text-muted small">20px</span>
              </div>
            </div>
          </div>

          <div id="helper-message" class="helper-message text-muted small" aria-live="polite"></div>

          <div id="text-container" class="reading-text mt-3" tabindex="0" aria-label="Reading text">
            {% set non_english_words = ['bonjour', 'amigo', 'sayonara', 'caf√©', 'fa√ßade', 'jalape√±o', 'r√©sum√©', 'na√Øve'] %}
            {% for word in page.content.split() %}
              {% set stripped_word = word.strip(".,;!?()‚Äù‚Äú:\"'") %}
              {% set is_proper_noun = stripped_word and stripped_word[0].isupper() and not loop.first %}
              {% set is_non_english = stripped_word and stripped_word|lower in non_english_words %}
              {% set word_classes = ['word'] %}
              {% if is_proper_noun %}{% set _ = word_classes.append('proper-noun') %}{% endif %}
              {% if is_non_english %}{% set _ = word_classes.append('non-english') %}{% endif %}
              <span
                class="{{ ' '.join(word_classes) }}"
                data-word-index="{{ loop.index0 }}"
                data-original="{{ word }}"
              >{{ word }}</span>
            {% endfor %}
          </div>

          <div class="card sr-output mt-4">
            <div class="card-body py-3">
              <h6 class="mb-2">Speech recognition</h6>
              <p id="recognized-text" class="mb-0" aria-live="polite"></p>
            </div>
          </div>

          <button
            id="next-btn"
            type="button"
            class="btn btn-success btn-block mt-4"
            style="display: none;"
            data-last-page="{{ 'true' if is_last_page else 'false' }}"
          >
            {% if is_last_page %}Back to activities{% else %}Go to page {{ page.page_number + 1 }}{% endif %}
          </button>
        </div>
      </div>
    </div>

    <div class="col-lg-4">
      <div class="card reading-help-card">
        <div class="card-body">
          <h5 class="card-title">Tips for a smooth session</h5>
          <ul class="reading-tips list-unstyled mb-3">
            <li><strong>Start</strong> the listener and read aloud at a natural pace.</li>
            <li>The highlighted word shows where you are. Click any word to hear it again.</li>
            <li>Need a breather? Pause at any time or skip tricky words.</li>
            <li>Finishing a page automatically unlocks the next one.</li>
          </ul>
          <div id="support-warning" class="alert alert-warning small" role="alert" hidden>
            Speech recognition is not available in your browser. You can still read and track progress manually.
          </div>
          <div class="form-group mb-0">
            <label for="voice-select" class="small text-uppercase text-muted">Voice for pronunciations</label>
            <select id="voice-select" class="form-control form-control-sm"></select>
            <small class="form-text text-muted">Choose a voice for the pronunciation helper.</small>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const elements = {
      textContainer: document.getElementById('text-container'),
      wordProgressBar: document.getElementById('word-progress-bar'),
      wordProgressText: document.getElementById('word-progress-text'),
      pageProgressText: document.getElementById('page-progress-text'),
      helperMessage: document.getElementById('helper-message'),
      recognizedText: document.getElementById('recognized-text'),
      statusBadge: document.getElementById('recognition-status'),
      startBtn: document.getElementById('start-btn'),
      stopBtn: document.getElementById('stop-btn'),
      skipBtn: document.getElementById('skip-btn'),
      repeatBtn: document.getElementById('repeat-btn'),
      restartBtn: document.getElementById('restart-btn'),
      nextBtn: document.getElementById('next-btn'),
      supportWarning: document.getElementById('support-warning'),
      voiceSelect: document.getElementById('voice-select'),
      fontSizeControl: document.getElementById('font-size-control'),
      fontSizeValue: document.getElementById('font-size-value')
    };

    if (!elements.textContainer) {
      return;
    }

    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const wordElements = Array.from(elements.textContainer.querySelectorAll('.word'));
    const totalWords = wordElements.length;

    const state = {
      currentIndex: 0,
      incorrectAttempts: 0,
      recognition: null,
      recognitionSupported: false,
      recognitionRequested: false,
      recognitionActive: false,
      isSpeaking: false,
      lastTranscriptTokens: [],
      processedTokens: 0,
      displayTranscript: ''
    };

    const config = {
      pronunciationThreshold: 4,
      skipThreshold: 8
    };

    const statusStyles = {
      idle: 'badge-secondary',
      listening: 'badge-success',
      paused: 'badge-warning',
      speaking: 'badge-info',
      completed: 'badge-success',
      error: 'badge-danger',
      unsupported: 'badge-danger'
    };

    const contractionsMap = new Map(Object.entries({
      "aren't": 'are not',
      "can't": 'cannot',
      "couldn't": 'could not',
      "didn't": 'did not',
      "doesn't": 'does not',
      "don't": 'do not',
      "hadn't": 'had not',
      "hasn't": 'has not',
      "haven't": 'have not',
      "he'd": 'he would',
      "he'll": 'he will',
      "he's": 'he is',
      "i'd": 'i would',
      "i'll": 'i will',
      "i'm": 'i am',
      "i've": 'i have',
      "isn't": 'is not',
      "it'd": 'it would',
      "it'll": 'it will',
      "it's": 'it is',
      "let's": 'let us',
      "might've": 'might have',
      "mustn't": 'must not',
      "shan't": 'shall not',
      "she'd": 'she would',
      "she'll": 'she will',
      "she's": 'she is',
      "shouldn't": 'should not',
      "that's": 'that is',
      "there's": 'there is',
      "they'd": 'they would',
      "they'll": 'they will',
      "they're": 'they are',
      "they've": 'they have',
      "we'd": 'we would',
      "we'll": 'we will',
      "we're": 'we are',
      "we've": 'we have',
      "weren't": 'were not',
      "what's": 'what is',
      "who's": 'who is',
      "won't": 'will not',
      "wouldn't": 'would not',
      "you're": 'you are',
      "you'd": 'you would',
      "you'll": 'you will',
      "you've": 'you have'
    }));

    const spellingVariantsMap = new Map(Object.entries({
      'color': 'colour',
      'flavor': 'flavour',
      'favorite': 'favourite',
      'center': 'centre',
      'theater': 'theatre',
      'analyze': 'analyse',
      'apologize': 'apologise',
      'organize': 'organise',
      'recognize': 'recognise',
      'traveler': 'traveller',
      'jewelry': 'jewellery',
      'meter': 'metre',
      'fiber': 'fibre',
      'gray': 'grey',
      'catalog': 'catalogue'
    }));

    const specialNumberPhrases = new Map(Object.entries({
      'twenty one': 21,
      'twenty two': 22,
      'twenty three': 23,
      'twenty four': 24,
      'twenty five': 25,
      'thirty one': 31,
      'thirty two': 32,
      'forty five': 45,
      'fifty five': 55,
      'sixty seven': 67,
      'seventy one': 71,
      'seventy two': 72,
      'seventy three': 73,
      'nineteen seventy two': 1972,
      'nineteen eighty four': 1984,
      'nineteen ninety nine': 1999,
      'two thousand': 2000,
      'two thousand one': 2001,
      'two thousand two': 2002,
      'two thousand three': 2003,
      'two thousand four': 2004,
      'two thousand five': 2005,
      'two thousand six': 2006,
      'two thousand seven': 2007,
      'two thousand eight': 2008,
      'two thousand nine': 2009,
      'two thousand ten': 2010,
      'two thousand eleven': 2011,
      'two thousand twelve': 2012,
      'two thousand thirteen': 2013,
      'two thousand fourteen': 2014,
      'two thousand fifteen': 2015,
      'two thousand sixteen': 2016,
      'two thousand seventeen': 2017,
      'two thousand eighteen': 2018,
      'two thousand nineteen': 2019,
      'twenty twenty': 2020,
      'twenty twenty one': 2021,
      'twenty twenty two': 2022,
      'twenty twenty three': 2023,
      'twenty twenty four': 2024,
      'twenty twenty five': 2025
    }));

    const wordMetadata = wordElements.map((element, index) => {
      const raw = element.dataset.original || element.textContent || '';
      const normalized = normalizeWord(raw);
      const baseSegments = normalized.replace(/-/g, ' ').split(/\s+/).filter(Boolean);
      const defaultSegments = baseSegments.length ? baseSegments : (normalized ? [normalized] : []);
      const variants = [];
      if (defaultSegments.length) {
        variants.push(defaultSegments);
      }
      const contractionExpansion = contractionsMap.get(normalized);
      if (contractionExpansion) {
        const expansionSegments = contractionExpansion
          .split(/\s+/)
          .map((part) => normalizeWord(part))
          .filter(Boolean);
        if (expansionSegments.length && !variants.some((variant) => arraysEqual(variant, expansionSegments))) {
          variants.push(expansionSegments);
        }
      }
      return {
        element,
        index,
        raw,
        normalized,
        segments: defaultSegments,
        variants,
        isProperNoun: element.classList.contains('proper-noun'),
        isNonEnglish: element.classList.contains('non-english')
      };
    });

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (SpeechRecognition) {
      state.recognitionSupported = true;
      state.recognition = new SpeechRecognition();
      state.recognition.lang = 'en-US';
      state.recognition.interimResults = true;
      state.recognition.continuous = true;

      state.recognition.onstart = () => {
        state.recognitionActive = true;
        setStatus('listening', 'Listening');
        updateControls();
      };

      state.recognition.onend = () => {
        state.recognitionActive = false;
        updateControls();

        if (state.isSpeaking) {
          return;
        }

        if (state.recognitionRequested && state.currentIndex < totalWords) {
          window.setTimeout(() => safeStartRecognition(), 400);
        } else if (state.currentIndex >= totalWords) {
          setStatus('completed', 'Completed');
        } else if (!state.recognitionRequested) {
          setStatus('paused', 'Paused');
        }
      };

      state.recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        setStatus('error', 'Microphone error');
        updateHelperMessage('We could not access your microphone. Check permissions and try again.');
      };

      state.recognition.onresult = (event) => {
        if (!event.results || !event.results.length) {
          return;
        }

        let interimTranscript = '';
        const startIndex = Number.isInteger(event.resultIndex) ? event.resultIndex : 0;

        for (let index = startIndex; index < event.results.length; index += 1) {
          const result = event.results[index];
          if (!result || !result[0]) {
            continue;
          }

          const transcript = result[0].transcript.trim();
          if (!transcript) {
            continue;
          }

          if (result.isFinal) {
            state.displayTranscript = `${state.displayTranscript} ${transcript}`.trim();
            handleTranscript(transcript.toLowerCase());
          } else {
            interimTranscript = transcript;
          }
        }

        const combinedTranscript = `${state.displayTranscript} ${interimTranscript}`.trim();
        elements.recognizedText.textContent = combinedTranscript;
      };
    } else {
      setStatus('unsupported', 'Unavailable');
      elements.startBtn.disabled = true;
      elements.stopBtn.disabled = true;
      if (elements.supportWarning) {
        elements.supportWarning.hidden = false;
      }
    }

    const synthesisSupported = 'speechSynthesis' in window;
    let availableVoices = [];

    if (!synthesisSupported) {
      elements.repeatBtn.disabled = true;
      elements.voiceSelect.disabled = true;
      elements.voiceSelect.innerHTML = '<option>Not supported</option>';
    } else {
      const populateVoices = () => {
        availableVoices = window.speechSynthesis.getVoices().filter((voice) => voice.lang && voice.lang.toLowerCase().startsWith('en'));
        elements.voiceSelect.innerHTML = '';
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = availableVoices.length ? 'System default' : 'Voice unavailable';
        elements.voiceSelect.appendChild(defaultOption);
        availableVoices.forEach((voice) => {
          const option = document.createElement('option');
          option.value = voice.name;
          option.textContent = `${voice.name} (${voice.lang})`;
          elements.voiceSelect.appendChild(option);
        });
        elements.voiceSelect.disabled = availableVoices.length === 0;
      };

      populateVoices();
      if (typeof window.speechSynthesis.onvoiceschanged !== 'undefined') {
        window.speechSynthesis.onvoiceschanged = populateVoices;
      }
    }

    updateFontSize();
    highlightWord(0);
    updateControls();
    updateHelperMessage('Press ‚ÄúStart reading‚Äù and begin speaking when you are ready.');

    elements.startBtn.addEventListener('click', () => {
      if (!state.recognitionSupported || state.currentIndex >= totalWords) {
        return;
      }
      state.recognitionRequested = true;
      safeStartRecognition();
      updateHelperMessage('Listening‚Ä¶ read the highlighted word aloud.');
    });

    elements.stopBtn.addEventListener('click', () => {
      state.recognitionRequested = false;
      safeStopRecognition();
      setStatus('paused', 'Paused');
      updateHelperMessage('Paused. Press ‚ÄúStart reading‚Äù when you are ready to continue.');
    });

    elements.skipBtn.addEventListener('click', () => {
      skipCurrentWord('user');
    });

    elements.restartBtn.addEventListener('click', () => {
      resetPageProgress();
    });

    if (elements.nextBtn) {
      const nextPageUrl = {% if not is_last_page %}'{{ url_for("reading.reading_activity", activity_id=activity.id, page_number=page.page_number + 1) }}'{% else %}null{% endif %};
      const activitiesUrl = '{{ url_for("reading.reading_tasks") }}';
      elements.nextBtn.addEventListener('click', () => {
        if (elements.nextBtn.dataset.lastPage === 'true') {
          window.location.href = activitiesUrl;
        } else if (nextPageUrl) {
          window.location.href = nextPageUrl;
        }
      });
    }

    if (synthesisSupported) {
      elements.repeatBtn.addEventListener('click', () => {
        pronounceCurrentWord();
      });
    }

    if (elements.fontSizeControl) {
      elements.fontSizeControl.addEventListener('input', updateFontSize);
    }

    wordElements.forEach((wordElement) => {
      wordElement.addEventListener('click', () => {
        const index = Number.parseInt(wordElement.dataset.wordIndex || '0', 10);
        if (Number.isInteger(index)) {
          state.currentIndex = index;
          state.incorrectAttempts = 0;
          highlightWord(state.currentIndex);
          if (synthesisSupported) {
            pronounceCurrentWord();
          }
        }
      });
    });

    function updateFontSize() {
      if (!elements.fontSizeControl) {
        return;
      }
      const value = Number.parseInt(elements.fontSizeControl.value, 10) || 20;
      elements.textContainer.style.fontSize = `${value}px`;
      if (elements.fontSizeValue) {
        elements.fontSizeValue.textContent = `${value}px`;
      }
    }

    function normalizeWord(word) {
      if (!word) {
        return '';
      }
      return word
        .toLowerCase()
        .replace(/[‚Äú‚Äù]/g, '"')
        .replace(/[‚Äô‚Äò]/g, "'")
        .replace(/^[\s.,;!?()"\[\]{}*&%$#@^~`+|\\/]+|[\s.,;!?()"\[\]{}*&%$#@^~`+|\\/]+$/g, '')
        .trim();
    }

    function safeStartRecognition() {
      if (!state.recognition || state.recognitionActive) {
        return;
      }
      try {
        state.recognition.start();
      } catch (error) {
        console.warn('Unable to start recognition:', error);
      }
    }

    function safeStopRecognition() {
      if (!state.recognition || !state.recognitionActive) {
        return;
      }
      try {
        state.recognition.stop();
      } catch (error) {
        console.warn('Unable to stop recognition:', error);
      }
    }

    function highlightWord(index) {
      wordMetadata.forEach((word) => {
        if (word.index === index) {
          word.element.classList.add('current-word');
          if (!prefersReducedMotion) {
            word.element.scrollIntoView({ block: 'center', behavior: 'smooth' });
          }
        } else {
          word.element.classList.remove('current-word');
        }
      });
      updateControls();
      updateProgress();
    }

    function updateProgress() {
      const completedWords = wordMetadata.filter((word) => word.element.classList.contains('word-correct') || word.element.classList.contains('skipped')).length;
      const percent = totalWords ? Math.min(100, Math.round((completedWords / totalWords) * 100)) : 0;
      elements.wordProgressBar.style.width = `${percent}%`;
      elements.wordProgressBar.setAttribute('aria-valuenow', `${percent}`);
      elements.wordProgressText.textContent = `${completedWords} / ${totalWords} words`;
      if (percent === 100) {
        elements.pageProgressText.textContent = 'Page complete!';
      } else {
        const currentPosition = Math.min(state.currentIndex + 1, totalWords);
        elements.pageProgressText.textContent = `On word ${currentPosition} of ${totalWords}`;
      }
    }

    function setStatus(status, label) {
      if (!elements.statusBadge) {
        return;
      }
      const className = statusStyles[status] || statusStyles.idle;
      elements.statusBadge.className = `badge ${className}`;
      elements.statusBadge.textContent = label || status.charAt(0).toUpperCase() + status.slice(1);
    }

    function updateControls() {
      const hasWordsRemaining = state.currentIndex < totalWords;
      elements.startBtn.disabled = !state.recognitionSupported || state.recognitionActive || !hasWordsRemaining;
      elements.stopBtn.disabled = !state.recognitionSupported || !state.recognitionActive;
      elements.skipBtn.disabled = !hasWordsRemaining;
      elements.repeatBtn.disabled = !synthesisSupported || !hasWordsRemaining;
      elements.restartBtn.disabled = state.currentIndex === 0;
    }

    function updateHelperMessage(message) {
      if (!elements.helperMessage) {
        return;
      }
      elements.helperMessage.textContent = message || '';
    }

    function handleTranscript(transcript) {
      if (state.currentIndex >= totalWords) {
        return;
      }

      const tokens = transcript
        .split(/\s+/)
        .map((token) => token.trim())
        .filter(Boolean)
        .map((token) => contractionsMap.get(token) || token)
        .join(' ')
        .split(/\s+/)
        .map((token) => normalizeWord(token))
        .filter(Boolean);

      if (!tokens.length) {
        return;
      }

      const previousTokens = state.lastTranscriptTokens || [];
      const prefixLength = previousTokens.length ? longestCommonPrefix(previousTokens, tokens) : 0;
      let pointer = Math.min(state.processedTokens || 0, prefixLength);
      const originalPointer = pointer;
      let matchedWords = 0;

      while (state.currentIndex < totalWords) {
        const currentWord = wordMetadata[state.currentIndex];
        if (!currentWord) {
          break;
        }

        if (!currentWord.segments.length) {
          moveToNextWord();
          continue;
        }

        const match = findWordMatch(currentWord, tokens, pointer);
        if (!match) {
          break;
        }

        pointer = match.end;
        acceptWord(currentWord);
        matchedWords += 1;
      }

      state.lastTranscriptTokens = tokens;
      state.processedTokens = pointer;

      const unprocessedTokens = Math.max(0, tokens.length - originalPointer);

      if (matchedWords === 0 && unprocessedTokens > 0) {
        const currentWord = wordMetadata[state.currentIndex];
        if (currentWord) {
          const minRequiredTokens = getMinimumVariantLength(currentWord);
          if (minRequiredTokens > 0 && unprocessedTokens >= minRequiredTokens) {
            registerIncorrectAttempt(currentWord);
          }
        }
      }
    }

    function findWordMatch(word, tokens, startIndex) {
      if (!word || !tokens.length) {
        return null;
      }

      const variants = getVariantSegments(word);
      if (!variants.length) {
        return null;
      }

      for (let start = startIndex; start < tokens.length; start += 1) {
        for (const variant of variants) {
          if (!variant.length || start + variant.length > tokens.length) {
            continue;
          }
          const candidate = tokens.slice(start, start + variant.length);
          if (segmentsMatchVariant(word, variant, candidate)) {
            return { start, end: start + variant.length };
          }
        }
      }

      return null;
    }

    function getVariantSegments(word) {
      if (!word) {
        return [];
      }
      if (Array.isArray(word.variants) && word.variants.length) {
        return word.variants;
      }
      if (Array.isArray(word.segments) && word.segments.length) {
        return [word.segments];
      }
      return [];
    }

    function getMinimumVariantLength(word) {
      const variants = getVariantSegments(word);
      if (!variants.length) {
        return 0;
      }
      let minLength = Number.POSITIVE_INFINITY;
      variants.forEach((variant) => {
        if (variant.length) {
          minLength = Math.min(minLength, variant.length);
        }
      });
      return Number.isFinite(minLength) ? minLength : 0;
    }

    function segmentsMatchVariant(expectedWord, variantSegments, spokenSegment) {
      if (!variantSegments.length || variantSegments.length !== spokenSegment.length) {
        return false;
      }

      if (expectedWord && expectedWord.isProperNoun) {
        return spokenSegment.some((segment) => Boolean(segment && segment.length));
      }

      const directMatch = variantSegments.every((segment, idx) => segment === spokenSegment[idx]);
      if (directMatch) {
        return true;
      }

      const expectedPhrase = variantSegments.join(' ').replace(/-/g, ' ').trim();
      const spokenPhrase = spokenSegment.join(' ').replace(/-/g, ' ').trim();

      if (areNumbersEquivalent(expectedPhrase, spokenPhrase)) {
        return true;
      }

      if (variantSegments.length === 1) {
        const expected = variantSegments[0];
        const spoken = spokenSegment[0];
        if (areSpellingVariants(expected, spoken)) {
          return true;
        }
        if (!expectedWord.isProperNoun && !expectedWord.isNonEnglish && wordsAreSimilar(expected, spoken)) {
          return true;
        }
      }

      return false;
    }

    function longestCommonPrefix(a, b) {
      if (!Array.isArray(a) || !Array.isArray(b)) {
        return 0;
      }
      const limit = Math.min(a.length, b.length);
      let index = 0;
      while (index < limit && a[index] === b[index]) {
        index += 1;
      }
      return index;
    }

    function arraysEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) {
        return false;
      }
      return a.every((value, index) => value === b[index]);
    }

    function areNumbersEquivalent(expectedPhrase, spokenPhrase) {
      const expectedNumber = parseNumberPhrase(expectedPhrase);
      const spokenNumber = parseNumberPhrase(spokenPhrase);
      if (expectedNumber === null || spokenNumber === null) {
        return false;
      }
      return expectedNumber === spokenNumber;
    }

    function areSpellingVariants(a, b) {
      if (a === b) {
        return true;
      }
      return spellingVariantsMap.get(a) === b || spellingVariantsMap.get(b) === a;
    }

    function wordsAreSimilar(expected, spoken) {
      if (expected === spoken) {
        return true;
      }
      const distance = levenshteinDistance(expected, spoken);
      const threshold = expected.length <= 4 ? 1 : Math.floor(expected.length / 4);
      return distance <= Math.max(1, threshold);
    }

    function acceptWord(word) {
      word.element.classList.remove('current-word', 'incorrect', 'skipped');
      word.element.classList.add('word-correct');
      state.currentIndex += 1;
      state.incorrectAttempts = 0;
      updateProgress();
      if (state.currentIndex >= totalWords) {
        finishPage();
      } else {
        highlightWord(state.currentIndex);
        updateHelperMessage('Great! Keep going.');
      }
    }

    function moveToNextWord() {
      state.currentIndex += 1;
      state.incorrectAttempts = 0;
      if (state.currentIndex >= totalWords) {
        finishPage();
      } else {
        highlightWord(state.currentIndex);
      }
    }

    function registerIncorrectAttempt(word) {
      state.incorrectAttempts += 1;
      word.element.classList.add('incorrect');
      updateHelperMessage('That didn\'t quite match. Try once more.');
      window.setTimeout(() => {
        word.element.classList.remove('incorrect');
      }, 600);

      if (state.incorrectAttempts === config.pronunciationThreshold) {
        updateHelperMessage('Here is how it sounds. Listen and repeat.');
        pronounceCurrentWord();
      }

      if (state.incorrectAttempts >= config.skipThreshold) {
        skipCurrentWord('auto');
      }
    }

    function skipCurrentWord(reason) {
      if (state.currentIndex >= totalWords) {
        return;
      }
      const currentWord = wordMetadata[state.currentIndex];
      currentWord.element.classList.remove('current-word', 'incorrect');
      currentWord.element.classList.add('skipped');
      state.currentIndex += 1;
      state.incorrectAttempts = 0;
      state.lastTranscriptTokens = [];
      state.processedTokens = 0;
      if (reason === 'user') {
        updateHelperMessage('Word skipped. You can review it later.');
      } else {
        updateHelperMessage('Let\'s move on to the next word.');
      }
      if (state.currentIndex >= totalWords) {
        finishPage();
      } else {
        highlightWord(state.currentIndex);
      }
    }

    function finishPage() {
      setStatus('completed', 'Completed');
      updateHelperMessage('Excellent work! Continue when you are ready.');
      state.recognitionRequested = false;
      state.lastTranscriptTokens = [];
      state.processedTokens = 0;
      safeStopRecognition();
      updateControls();
      if (elements.nextBtn) {
        elements.nextBtn.style.display = 'block';
      }
      {% if not is_last_page %}
      unlockNextPage();
      {% endif %}
    }

    function resetPageProgress() {
      state.currentIndex = 0;
      state.incorrectAttempts = 0;
      state.recognitionRequested = false;
      state.lastTranscriptTokens = [];
      state.processedTokens = 0;
      state.displayTranscript = '';
      safeStopRecognition();
      if (elements.recognizedText) {
        elements.recognizedText.textContent = '';
      }
      wordMetadata.forEach((word) => {
        word.element.classList.remove('current-word', 'incorrect', 'word-correct', 'skipped');
      });
      highlightWord(0);
      updateProgress();
      updateHelperMessage('Page restarted. Press ‚ÄúStart reading‚Äù when you are ready.');
      setStatus('idle', 'Idle');
      if (elements.nextBtn) {
        elements.nextBtn.style.display = 'none';
      }
    }

    function pronounceCurrentWord() {
      if (!synthesisSupported || state.currentIndex >= totalWords) {
        return;
      }
      const currentWord = wordMetadata[state.currentIndex];
      const utterance = new SpeechSynthesisUtterance(currentWord.raw);
      const selectedName = elements.voiceSelect.value;
      const voice = availableVoices.find((item) => item.name === selectedName);
      if (voice) {
        utterance.voice = voice;
      }
      utterance.rate = 0.9;
      utterance.onstart = () => {
        state.isSpeaking = true;
        setStatus('speaking', 'Speaking');
        if (state.recognitionActive) {
          safeStopRecognition();
        }
      };
      utterance.onend = () => {
        state.isSpeaking = false;
        setStatus(state.recognitionRequested ? 'listening' : 'paused', state.recognitionRequested ? 'Listening' : 'Paused');
        if (state.recognitionRequested && state.currentIndex < totalWords) {
          safeStartRecognition();
        }
      };
      utterance.onerror = () => {
        state.isSpeaking = false;
        setStatus('error', 'Speech error');
      };
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(utterance);
    }

    function unlockNextPage() {
      const unlockUrl = '{{ url_for("reading.unlock_page", activity_id=activity.id, page_number=page.page_number + 1) }}';
      window.fetch(unlockUrl, {
        method: 'POST',
        credentials: 'same-origin',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': '{{ csrf_token }}'
        },
        body: JSON.stringify({ completed: true })
      }).catch((error) => {
        console.error('Unable to unlock next page:', error);
        updateHelperMessage('Progress saved locally. If the next page does not unlock, refresh the page.');
      });
    }

    function parseNumberPhrase(phrase) {
      if (!phrase) {
        return null;
      }
      const compactDigits = phrase.replace(/\s+/g, '');
      if (/^\d+$/.test(compactDigits)) {
        return Number.parseInt(compactDigits, 10);
      }
      const normalized = phrase.toLowerCase().replace(/-/g, ' ').replace(/\band\b/g, ' ').trim();
      if (specialNumberPhrases.has(normalized)) {
        return specialNumberPhrases.get(normalized);
      }
      const tokens = normalized.split(/\s+/).filter(Boolean);
      if (!tokens.length) {
        return null;
      }
      const units = new Map(Object.entries({
        zero: 0,
        one: 1,
        two: 2,
        three: 3,
        four: 4,
        five: 5,
        six: 6,
        seven: 7,
        eight: 8,
        nine: 9,
        ten: 10,
        eleven: 11,
        twelve: 12,
        thirteen: 13,
        fourteen: 14,
        fifteen: 15,
        sixteen: 16,
        seventeen: 17,
        eighteen: 18,
        nineteen: 19
      }));
      const tens = new Map(Object.entries({
        twenty: 20,
        thirty: 30,
        forty: 40,
        fifty: 50,
        sixty: 60,
        seventy: 70,
        eighty: 80,
        ninety: 90
      }));
      const scales = new Map(Object.entries({
        hundred: 100,
        thousand: 1000,
        million: 1_000_000
      }));

      let total = 0;
      let current = 0;
      let valid = false;

      for (const token of tokens) {
        if (token === 'and') {
          continue;
        }
        if (units.has(token)) {
          current += units.get(token);
          valid = true;
        } else if (tens.has(token)) {
          current += tens.get(token);
          valid = true;
        } else if (scales.has(token)) {
          const scale = scales.get(token);
          if (current === 0) {
            current = 1;
          }
          current *= scale;
          if (scale >= 1000) {
            total += current;
            current = 0;
          }
          valid = true;
        } else {
          return null;
        }
      }

      return valid ? total + current : null;
    }

    function levenshteinDistance(a, b) {
      const matrix = Array.from({ length: b.length + 1 }, () => new Array(a.length + 1).fill(0));
      for (let i = 0; i <= a.length; i += 1) {
        matrix[0][i] = i;
      }
      for (let j = 0; j <= b.length; j += 1) {
        matrix[j][0] = j;
      }
      for (let j = 1; j <= b.length; j += 1) {
        for (let i = 1; i <= a.length; i += 1) {
          if (a[i - 1] === b[j - 1]) {
            matrix[j][i] = matrix[j - 1][i - 1];
          } else {
            matrix[j][i] = Math.min(
              matrix[j - 1][i] + 1,
              matrix[j][i - 1] + 1,
              matrix[j - 1][i - 1] + 1
            );
          }
        }
      }
      return matrix[b.length][a.length];
    }
  });
</script>
{% endblock %}

{% block styles %}
{{ super() }}
<style>
  .reading-view {
    padding-bottom: 2rem;
  }

  .reading-card {
    border: none;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
  }

  .reading-help-card {
    border: none;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.06);
    position: sticky;
    top: 90px;
  }

  .reading-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 1rem;
    flex-wrap: wrap;
  }

  .reading-title {
    font-size: 1.75rem;
    font-weight: 700;
    color: #1f2a44;
  }

  .reading-subtitle {
    font-size: 0.95rem;
  }

  .reading-progress {
    height: 0.5rem;
    background-color: #f0f4f8;
  }

  .reading-progress .progress-bar {
    background: linear-gradient(90deg, #4caf50, #2e7d32);
  }

  .reading-controls .btn {
    min-width: 120px;
  }

  .reading-font-control {
    display: flex;
    align-items: center;
    min-width: 220px;
  }

  .reading-text {
    background-color: #f8fafc;
    border-radius: 12px;
    padding: 1.5rem;
    min-height: 280px;
    max-height: 60vh;
    overflow-y: auto;
    line-height: 1.8;
    outline: none;
  }

  .reading-text:focus {
    box-shadow: 0 0 0 0.2rem rgba(76, 175, 80, 0.25);
  }

  .word {
    padding: 0.2rem 0.25rem;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s ease, transform 0.2s ease;
    display: inline-block;
    margin-right: 0.15rem;
  }

  .word:hover {
    background-color: rgba(76, 175, 80, 0.1);
  }

  .proper-noun {
    font-style: italic;
  }

  .non-english {
    text-decoration: underline;
  }

  .current-word {
    background-color: #ffef99;
    box-shadow: 0 0 0 1px rgba(255, 215, 0, 0.6);
  }

  .word-correct {
    background-color: rgba(76, 175, 80, 0.25);
    color: #1b5e20;
    font-weight: 600;
  }

  .incorrect {
    border-bottom: 2px solid #e53935;
  }

  .skipped {
    text-decoration: line-through;
    color: #6c757d;
  }

  .helper-message {
    min-height: 1.5rem;
  }

  .sr-output {
    background-color: #f9fbfd;
    border: none;
    box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.05);
  }

  .sr-output p {
    min-height: 1.5rem;
    color: #0d47a1;
    font-style: italic;
  }

  .reading-tips li {
    padding-left: 1.4rem;
    position: relative;
    margin-bottom: 0.75rem;
  }

  .reading-tips li::before {
    content: '‚úî';
    position: absolute;
    left: 0;
    top: 0.1rem;
    color: #4caf50;
  }

  @media (max-width: 991.98px) {
    .reading-help-card {
      position: static;
      margin-top: 1.5rem;
    }

    .reading-controls .btn {
      min-width: auto;
    }

    .reading-font-control {
      width: 100%;
    }
  }

  @media (max-width: 575.98px) {
    .reading-title {
      font-size: 1.5rem;
    }

    .reading-text {
      padding: 1.25rem;
    }
  }
</style>
{% endblock %}
