<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spider Preposition Practice</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Basic styling for the canvas */
        canvas {
            background-color: #e0f2f7; /* Light blue background */
            border: 2px solid #0284c7; /* Blue border */
            display: block;
            margin: 20px auto; /* Center the canvas */
            cursor: pointer; /* Indicate it's interactive */
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="bg-white p-6 rounded-lg shadow-xl text-center">
        <h1 class="text-2xl font-bold mb-4 text-blue-700">Spider Preposition Practice</h1>
        <p id="question" class="text-xl mb-4 text-gray-800">Loading game...</p>

        <canvas id="gameCanvas" width="600" height="400"></canvas>

        <p id="feedback" class="text-lg mt-4 font-semibold"></p>

        <button id="nextButton" class="mt-4 px-6 py-2 bg-blue-500 text-white rounded-lg shadow hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-50 hidden">Next Question</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const questionElement = document.getElementById('question');
        const feedbackElement = document.getElementById('feedback');
        const nextButton = document.getElementById('nextButton');

        // Define the objects in the scene
        const objects = [];
        let availableQuestions = []; // Array to hold questions that haven't been asked yet
        let allPossibleQuestions = []; // Array to hold all possible questions

        // Function to draw a rectangle
        function drawRect(x, y, width, height, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, width, height);
        }

        // Function to draw a circle
        function drawCircle(x, y, radius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
        }

         // Function to draw a polygon (for more complex shapes)
        function drawPolygon(points, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();
            ctx.fill();
        }


        // Function to draw a simple spider
        function drawSpider(x, y, size, color) {
            ctx.fillStyle = color;

            // Body (larger circle)
            ctx.beginPath();
            ctx.arc(x, y, size * 1.2, 0, Math.PI * 2);
            ctx.fill();

            // Head (smaller circle)
            ctx.beginPath();
            ctx.arc(x + size * 1.5, y, size * 0.8, 0, Math.PI * 2);
            ctx.fill();

            // Legs (simple lines)
            ctx.lineWidth = size / 4;
            ctx.strokeStyle = color;
            ctx.beginPath();
            // Left legs
            ctx.moveTo(x - size, y - size); ctx.lineTo(x - size * 2, y - size * 2);
            ctx.moveTo(x - size, y); ctx.lineTo(x - size * 2, y);
            ctx.moveTo(x - size, y + size); ctx.lineTo(x - size * 2, y + size * 2);
            // Right legs
            ctx.moveTo(x + size, y - size); ctx.lineTo(x + size * 2, y - size * 2);
            ctx.moveTo(x + size, y); ctx.lineTo(x + size * 2, y);
            ctx.moveTo(x + size, y + size); ctx.lineTo(x + size * 2, y + size + 2);
            ctx.stroke();
        }


        // Function to draw the entire scene with more complex graphics
        function drawScene() {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            objects.length = 0; // Clear objects array for redrawing

            // Draw the ground
            drawRect(0, canvas.height - 50, canvas.width, 50, '#a3e635'); // Green ground

            // Draw the seesaw (more detailed)
            drawRect(170, canvas.height - 100, 10, 50, '#c2410c'); // Left leg
            drawRect(220, canvas.height - 100, 10, 50, '#c2410c'); // Right leg
            drawRect(160, canvas.height - 110, 90, 10, '#c2410c'); // Base connecting legs
            ctx.save(); // Save current context state
            ctx.translate(200, canvas.height - 110); // Move origin to pivot point
            ctx.rotate(-Math.PI / 12); // Rotate slightly
            drawRect(-100, -10, 200, 20, '#c2410c'); // Brown plank
            ctx.restore(); // Restore context state
            const seesaw = { type: 'seesaw', x: 160, y: canvas.height - 110, width: 90, height: 60 }; // Approximate bounding box for clicks
            objects.push(seesaw);


            // Draw the slide (more detailed)
            drawRect(350, canvas.height - 150, 20, 100, '#60a5fa'); // Left support
            drawRect(530, canvas.height - 150, 20, 100, '#60a5fa'); // Right support
            drawRect(350, canvas.height - 150, 200, 20, '#60a5fa'); // Top horizontal bar
            ctx.beginPath();
            ctx.moveTo(550, canvas.height - 130); // Start of slide surface
            ctx.lineTo(370, canvas.height - 50); // End of slide surface
            ctx.lineWidth = 30; // Width of the slide surface
            ctx.strokeStyle = '#60a5fa'; // Blue slide color
            ctx.stroke();
             const slide = { type: 'slide', x: 350, y: canvas.height - 150, width: 200, height: 100 }; // Approximate bounding box
             objects.push(slide);


            // Draw the net (more detailed - representing goal posts and net area)
            drawRect(500, canvas.height - 150, 10, 100, '#9ca3af'); // Left post
            drawRect(570, canvas.height - 150, 10, 100, '#9ca3af'); // Right post
            drawRect(500, canvas.height - 150, 80, 10, '#9ca3af'); // Top bar
            // Simple representation of the net mesh
            ctx.strokeStyle = '#cccccc'; // Lighter gray for net lines
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let i = 0; i < 7; i++) {
                ctx.moveTo(500, canvas.height - 140 + i * 15);
                ctx.lineTo(580, canvas.height - 140 + i * 15);
                ctx.moveTo(500 + i * 10, canvas.height - 150);
                ctx.lineTo(500 + i * 10, canvas.height - 50);
            }
            ctx.stroke();
            const net = { type: 'net', x: 500, y: canvas.height - 150, width: 80, height: 100 }; // Approximate bounding box
            objects.push(net);

             // Draw a tree (more detailed)
            drawRect(40, canvas.height - 250, 40, 200, '#78350f'); // Brown trunk
            // Leaves (multiple circles)
            drawCircle(60, canvas.height - 250, 40, '#16a34a');
            drawCircle(30, canvas.height - 230, 35, '#16a34a');
            drawCircle(90, canvas.height - 230, 35, '#16a34a');
             const tree = { type: 'tree', x: 20, y: canvas.height - 290, width: 100, height: 240 }; // Approximate bounding box
             objects.push(tree);

            // Draw the swing (simplified)
            drawRect(300, canvas.height - 200, 10, 150, '#c2410c'); // Left support
            drawRect(400, canvas.height - 200, 10, 150, '#c2410c'); // Right support
            drawRect(300, canvas.height - 200, 110, 10, '#c2410c'); // Top bar
            ctx.strokeStyle = '#000000'; // Black ropes
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(320, canvas.height - 190);
            ctx.lineTo(320, canvas.height - 100);
            ctx.moveTo(380, canvas.height - 190);
            ctx.lineTo(380, canvas.height - 100);
            ctx.stroke();
            drawRect(310, canvas.height - 100, 80, 10, '#ffbf00'); // Yellow seat
            const swing = { type: 'swing', x: 300, y: canvas.height - 200, width: 110, height: 160 }; // Approximate bounding box
            objects.push(swing);


            // Draw spiders in different positions
            const spiderSize = 8;
            const spiderColor = '#000000'; // Black spider

            // Spider on the seesaw plank
            const spiderOnSeesaw = { type: 'spider', x: 200, y: canvas.height - 110 - spiderSize, size: spiderSize, preposition: 'on', reference: 'seesaw' };
            drawSpider(spiderOnSeesaw.x, spiderOnSeesaw.y, spiderOnSeesaw.size, spiderColor);
            objects.push(spiderOnSeesaw);

            // Spider under the seesaw base
            const spiderUnderSeesaw = { type: 'spider', x: 200, y: canvas.height - 50 - spiderSize, size: spiderSize, preposition: 'under', reference: 'seesaw' };
            drawSpider(spiderUnderSeesaw.x, spiderUnderSeesaw.y, spiderUnderSeesaw.size, spiderColor);
            objects.push(spiderUnderSeesaw);

            // Spider on the slide surface
             const spiderOnSlide = { type: 'spider', x: 470, y: canvas.height - 90 - spiderSize, size: spiderSize, preposition: 'on', reference: 'slide' };
             drawSpider(spiderOnSlide.x, spiderOnSlide.y, spiderOnSlide.size, spiderColor);
             objects.push(spiderOnSlide);

            // Spider by the net post
            const spiderByNet = { type: 'spider', x: 590, y: canvas.height - 50 - spiderSize, size: spiderSize, preposition: 'by', reference: 'net' };
            drawSpider(spiderByNet.x, spiderByNet.y, spiderByNet.size, spiderColor);
            objects.push(spiderByNet);

             // Spider in the tree (on the trunk)
            const spiderInTree = { type: 'spider', x: 60, y: canvas.height - 180, size: spiderSize, preposition: 'in', reference: 'tree' };
            drawSpider(spiderInTree.x, spiderInTree.y, spiderInTree.size, spiderColor);
            objects.push(spiderInTree);

            // Spider on the swing seat
            const spiderOnSwing = { type: 'spider', x: 350, y: canvas.height - 100 - spiderSize, size: spiderSize, preposition: 'on', reference: 'swing' };
            drawSpider(spiderOnSwing.x, spiderOnSwing.y, spiderOnSwing.size, spiderColor);
            objects.push(spiderOnSwing);

            // After drawing, populate all possible questions
            allPossibleQuestions = objects.filter(obj => obj.type === 'spider' && obj.preposition && obj.reference)
                                           .map(spider => ({
                                               preposition: spider.preposition,
                                               targetObject: spider,
                                               referenceObject: objects.find(obj => obj.type === spider.reference)
                                           }));

            // Initialize available questions
            availableQuestions = [...allPossibleQuestions]; // Copy all questions to the available list
        }

        let currentQuestion = {};

        // Function to generate a new question
        function generateQuestion() {
            // Clear feedback and hide the next button
            feedbackElement.textContent = '';
            nextButton.classList.add('hidden');

            // Check if there are available questions
            if (availableQuestions.length === 0) {
                questionElement.textContent = "You finished all the questions! Great job!";
                canvas.style.pointerEvents = 'none'; // Disable clicks
                return; // Stop generating questions
            }

            // Randomly select an index from the available questions
            const randomIndex = Math.floor(Math.random() * availableQuestions.length);

            // Get the selected question and remove it from the available list
            currentQuestion = availableQuestions.splice(randomIndex, 1)[0];


            if (!currentQuestion.referenceObject) {
                 questionElement.textContent = `Error: Reference object for question not found.`;
                 return;
            }

            questionElement.textContent = `Click on the spider ${currentQuestion.preposition} the ${currentQuestion.referenceObject.type}.`;

             // Re-enable canvas clicks
            canvas.style.pointerEvents = 'auto';
        }

        // Function to check if a point is inside a circle (used for spider body and tree leaves)
        function isInsideCircle(pointX, pointY, circleX, circleY, radius) {
            const distance = Math.sqrt((pointX - circleX) ** 2 + (pointY - circleY) ** 2);
            return distance < radius;
        }

         // Function to check if a point is inside a rectangle (used for spider head and legs - simplified, and for rectangular objects)
         function isInsideRect(pointX, pointY, rectX, rectY, width, height) {
             return pointX > rectX && pointX < rectX + width && pointY > rectY && pointY < rectY + height;
         }


        // Function to handle clicks on the canvas
        canvas.addEventListener('click', (event) => {
            // If there are no more questions, do nothing on click
            if (availableQuestions.length === 0 && feedbackElement.textContent.includes("finished")) {
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            // Check if any object was clicked
            let clickedObject = null;
            // Iterate through objects in reverse to click the topmost if they overlap
            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                 if (obj.type === 'spider') {
                    // Check if click is inside the spider's body or head (simplified)
                    if (isInsideCircle(clickX, clickY, obj.x, obj.y, obj.size * 1.2) || // Body
                        isInsideCircle(clickX, clickY, obj.x + obj.size * 1.5, obj.y, obj.size * 0.8)) // Head
                        {
                        clickedObject = obj;
                        break; // Found the clicked spider
                    }
                }
                // Add checks for other shapes if needed later (though currently only spiders are clickable targets)
            }

            if (clickedObject) {
                // Check if the clicked object is the correct one for the current question
                if (clickedObject === currentQuestion.targetObject) {
                    feedbackElement.textContent = 'Correct!';
                    feedbackElement.className = 'text-lg mt-4 font-semibold text-green-700'; // Green text for correct
                    nextButton.classList.remove('hidden'); // Show next button
                     // Disable canvas clicks until the next question
                    canvas.style.pointerEvents = 'none';
                } else {
                    feedbackElement.textContent = 'Try again.';
                    feedbackElement.className = 'text-lg mt-4 font-semibold text-red-700'; // Red text for incorrect
                }
            }
        });

        // Event listener for the next button
        nextButton.addEventListener('click', generateQuestion);

        // Initial setup
        drawScene();
        generateQuestion();

    </script>

</body>
</html>
