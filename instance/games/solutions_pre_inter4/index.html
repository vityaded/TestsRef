<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Text Quest: Recon Patrol (Simplified¬†‚Äì Tooltip¬†Fix¬†v2)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            "dark-bg": "#2c3e50",
            "container-bg": "#34495e",
            "light-text": "#ecf0f1",
            accent: "#1abc9c",
            "accent-dark": "#16a085",
            highlight: "#f1c40f",
            location: "#95a5a6",
            danger: "#e74c3c",
            "danger-dark": "#c0392b",
            success: "#2ecc71",
            "border-color": "#4a6572",
            info: "#3498db",
          },
        },
      },
    };
  </script>
  <style>
        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #scene-text {
            min-height: 80px; /* Maintain minimum height */
            border-left: 4px solid config('theme.colors.accent');
            transition: background-color 0.5s ease, opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #scene-text.speaking {
            background-color: #4a6572; /* Indicate text is being spoken */
        }
        /* Used when showing Ukrainian during memory recall */
        #scene-text.memory-recall-active {
             border-left: 4px solid config('theme.colors.highlight');
        }

        button#restart-button {
            background-color: config('theme.colors.danger');
            margin-left: auto;
            margin-right: auto;
            width: fit-content;
        }
        button#restart-button:hover {
             background-color: config('theme.colors.danger-dark');
        }
        .keyword-highlight {
            color: config('theme.colors.highlight');
            font-weight: bold;
        }
        .memory-match {
             color: config('theme.colors.success'); /* Green for matched words */
             font-weight: bold;
        }
        .location-text {
             font-style: italic;
             color: config('theme.colors.location');
             display: block;
             margin-top: 0.5rem;
             font-size: 0.9em;
        }
        .game-over, .game-success { /* Combined common styles */
            font-weight: bold;
            text-align: center;
            font-size: 1.2em;
            margin-top: 1rem;
        }
        .game-over { color: config('theme.colors.danger'); }
        .game-success { color: config('theme.colors.success'); }

        #voice-button {
            transition: background-color 0.3s ease;
        }
        #voice-button.listening {
            background-color: config('theme.colors.info');
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; }
        }

        #voice-status {
            min-height: 1.5em; /* Ensure space for messages */
            margin-top: 0.75rem;
            text-align: center;
            font-style: italic;
            transition: color 0.3s ease;
        }
        /* Hide choice buttons during voice input phase */
        #choices-container.hidden {
            display: none;
        }
         /* Specific styling for choice buttons (kept simple as they aren't primary interaction) */
         #choices-container button {
            opacity: 0.7; /* Slightly faded as they are not primary */
            cursor: default; /* Not clickable by default */
         }


        #start-challenge-btn { /* Renamed from enable-audio-btn */
            display: block;
            margin: 1rem auto;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
         /* Style when audio is enabled */
        #start-challenge-btn.audio-enabled {
            background-color: config('theme.colors.success'); /* Green */
            cursor: default;
         }
         #start-challenge-btn.audio-enabled:hover {
             background-color: config('theme.colors.success'); /* Stay green */
         }
         #start-challenge-btn:disabled {
             background-color: config('theme.colors.location');
             cursor: not-allowed;
             opacity: 0.7;
         }

        #vocab-list-container {
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #vocab-list-container ul {
            list-style: none;
            padding: 0;
            margin: 0;
            columns: 2;
            -webkit-columns: 2;
            -moz-columns: 2;
        }
        #vocab-list-container li {
            margin-bottom: 0.3rem;
            color: config('theme.colors.light-text');
        }
        #vocab-list-container li .ua-term {
            color: config('theme.colors.accent');
            font-weight: 500;
        }
        #vocab-list-container.hidden {
           opacity: 0;
           visibility: hidden;
           height: 0;
           overflow: hidden;
           margin-bottom: 0; /* Collapse margin */
           padding: 0; /* Collapse padding */
           border: none; /* Collapse border */
        }
        /* === inline‚Äëtranslation tooltip ========================================= */
        .translatable-sentence{cursor:help;}
      /* ‚Ä¶¬†(UNCHANGED GLOBAL STYLES FROM ORIGINAL FILE) ‚Ä¶ */
      #translation-tooltip {
      position: fixed;
      z-index: 9999;
      max-width: 80%;
      background: rgba(52, 73, 94, 0.95);
      color: #ecf0f1;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 0.9rem;
      line-height: 1.25;
      display: none;
      pointer-events: auto;
      transition: opacity 0.15s ease;
    }
  </style>
</head>
<body class="bg-dark-bg text-light-text leading-relaxed">

<div class="max-w-2xl mx-auto my-5 p-5 border border-border-color shadow-lg rounded-lg">

    <button id="start-challenge-btn" class="bg-accent hover:bg-accent-dark text-white font-bold py-2 px-4 rounded">
         Start the challenge üöÄ
    </button>

    <div id="game-container" class="bg-container-bg p-6 rounded-md border border-border-color mt-4">
        <h1 class="text-accent text-center text-2xl font-bold border-b-2 border-accent-dark pb-2 mb-5">
            Recon Patrol
        </h1>

        <div id="vocab-list-container" class="bg-dark-bg p-3 mb-4 rounded border border-border-color text-sm hidden">
            </div>
        <div id="scene-text" class="bg-dark-bg p-4 rounded mb-6">
            Loading...
        </div>
        <div id="choices-container" class="space-y-3 mt-4 hidden">
            </div>
        <div class="mt-6 text-center">
             <button id="voice-button" class="bg-accent hover:bg-accent-dark text-white font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                 Speak Action üé§
             </button>
             <div id="feedback-percentage-area" class="text-center font-semibold mt-2 min-h-[1.2em]">
                </div>
             <div id="voice-status" class="text-info"></div>
        </div>
        <div id="outcome-display" class="mt-4">
            </div>
    </div>
</div>
<script>
// --- Game Data (Scenes) ---
// (Keep gameData object as is - too large to include here, assumed present from original)
// Teen Adventure ‚Äì WaveFest Quest (A2 level)
// Replace your existing gameData / vocabulary chunk with this one.
// Story practises Unit‚Äë4 weather & disaster vocabulary, road/location nouns,
// phrasal verbs, and comparatives/superlatives in simple A2 language.

/* === TEEN ROAD‚ÄëTRIP ADVENTURE ===
   WaveFest or Bust!  (Part¬†1 / 3)
   Same structure ‚Üí drop‚Äëin replacement for previous gameData.
*/

const gameData = {
  /* ---------- 0. INTRO ---------- */
  'start': {
    text: {
      en: "Friday morning. Grey clouds hang low over Riverside High. You, Sam, Leo and Maya are packing an old green van for WaveFest ‚Äì the biggest music festival of the year. Tickets? ‚úì Snacks? ‚úì Excitement? Definitely! [Location: School car park]",
      ua: "–†–∞–Ω–æ–∫ –ø‚Äô—è—Ç–Ω–∏—Ü—ñ. –°—ñ—Ä—ñ —Ö–º–∞—Ä–∏ –Ω–∏–∑—å–∫–æ –≤–∏—Å—è—Ç—å –Ω–∞–¥ —à–∫–æ–ª–æ—é –†—ñ–≤–µ—Ä—Å–∞–π–¥. –¢–∏, –°–µ–º, –õ–µ–æ —Ç–∞ –ú–∞–π—è –≤–∞–Ω—Ç–∞–∂–∏—Ç–µ —Å—Ç–∞—Ä–∏–π –∑–µ–ª–µ–Ω–∏–π —Ñ—É—Ä–≥–æ–Ω, —â–æ–±–∏ –≤–∏—Ä—É—à–∏—Ç–∏ –Ω–∞ WaveFest ‚Äì –Ω–∞–π–±—ñ–ª—å—à–∏–π –º—É–∑–∏—á–Ω–∏–π —Ñ–µ—Å—Ç–∏–≤–∞–ª—å —Ä–æ–∫—É. –ö–≤–∏—Ç–∫–∏? ‚úì –ó–∞–∫—É—Å–∫–∏? ‚úì –ó–±—É–¥–∂–µ–Ω–Ω—è? –ë–µ–∑–ø–µ—Ä–µ—á–Ω–æ! [–õ–æ–∫–∞—Ü—ñ—è: —à–∫—ñ–ª—å–Ω–∞ –∞–≤—Ç–æ—Å—Ç–æ—è–Ω–∫–∞]"
    },
    choices: [
      { text: "Check the weather forecast.", nextScene: 'check_weather' },
      { text: "Finish packing and jump inside.", nextScene: 'pack_van' },
      { text: "Ask Maya if she's excited.", nextScene: 'small_talk' }
    ]
  },

  /* ---------- 1. WEATHER WARNINGS ---------- */
  'check_weather': {
    text: {
      en: "You check your phone app. It shows a thunderstorm symbol. The forecast warns: *Possible hailstorm on highway A17.* Leo says, ‚ÄúWow, a hailstorm!‚Äù Maya looks worried: ‚ÄúHailstorms are more dangerous than rain showers.‚Äù",
      // Focus: weather vocab, comparative 'more dangerous than'
      ua: "–¢–∏ –ø–µ—Ä–µ–≤—ñ—Ä—è—î—à –¥–æ–¥–∞—Ç–æ–∫ –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω—ñ. –í—ñ–Ω –ø–æ–∫–∞–∑—É—î —Å–∏–º–≤–æ–ª –≥—Ä–æ–∑–∏. –ü—Ä–æ–≥–Ω–æ–∑ –ø–æ–ø–µ—Ä–µ–¥–∂–∞—î: *–ú–æ–∂–ª–∏–≤–∏–π –≥—Ä–∞–¥ –Ω–∞ —Ç—Ä–∞—Å—ñ A17.* –õ–µ–æ –∫–∞–∂–µ: ¬´–í–∞—É, –≥—Ä–∞–¥!¬ª –ú–∞–π—è –≤–∏–≥–ª—è–¥–∞—î —Å—Ç—É—Ä–±–æ–≤–∞–Ω–æ—é: ¬´–ì—Ä–∞–¥ –Ω–µ–±–µ–∑–ø–µ—á–Ω—ñ—à–∏–π, –Ω—ñ–∂ –∑–ª–∏–≤–∏.¬ª"
    },
    choices: [
      { text: "Suggest a safer route: 'Let's come up with a new plan.'", nextScene: 'choose_scenic' }, // Focus: phrasal verb 'come up with'
      { text: "Say 'Let's carry on! We can't put it off.'", nextScene: 'pack_van' } // Focus: phrasal verbs 'carry on', 'put off'
    ]
  },

  'small_talk': {
    text: {
      en: "You ask Maya, 'Are you excited for the festival?' She smiles, her eyes brighter than the cloudy sky: ‚ÄúYes! I can‚Äôt wait!‚Äù Leo interrupts: ‚ÄúOkay lovebirds, let's go! We need to wake up early tomorrow!‚Äù",
      // Focus: comparative 'brighter than', phrasal verb 'wake up'
      ua: "–¢–∏ –ø–∏—Ç–∞—î—à –ú–∞–π—é: '–¢–∏ –∑ –Ω–µ—Ç–µ—Ä–ø—ñ–Ω–Ω—è–º —á–µ–∫–∞—î—à –Ω–∞ —Ñ–µ—Å—Ç–∏–≤–∞–ª—å?' –í–æ–Ω–∞ –ø–æ—Å–º—ñ—Ö–∞—î—Ç—å—Å—è, —ó—ó –æ—á—ñ —è—Å–∫—Ä–∞–≤—ñ—à—ñ, –Ω—ñ–∂ —Ö–º–∞—Ä–Ω–µ –Ω–µ–±–æ: ¬´–¢–∞–∫! –ù–µ –º–æ–∂—É –¥–æ—á–µ–∫–∞—Ç–∏—Å—è!¬ª –õ–µ–æ –ø–µ—Ä–µ–±–∏–≤–∞—î: ¬´–ì–∞—Ä–∞–∑–¥, –∑–∞–∫–æ—Ö–∞–Ω—ñ, —Ä—É—à–∞–π–º–æ! –ù–∞–º —Ç—Ä–µ–±–∞ –∑–∞–≤—Ç—Ä–∞ —Ä–∞–Ω–æ –ø—Ä–æ–∫–∏–¥–∞—Ç–∏—Å—è!¬ª"
    },
    choices: [
      { text: "Help Leo start the van.", nextScene: 'pack_van' }
    ]
  },

  /* ---------- 2. HIT THE ROAD ---------- */
  'pack_van': {
    text: {
      en: "The engine starts. Music on! You head for highway A17. The weather is cloudy and cool, but everyone is happy.",
      // Focus: weather vocab
      ua: "–î–≤–∏–≥—É–Ω –∑–∞–ø—É—â–µ–Ω–æ. –ú—É–∑–∏–∫–∞ –≥—Ä–∞—î! –í–∏ –ø—Ä—è–º—É—î—Ç–µ –¥–æ —Ç—Ä–∞—Å–∏ A17. –ü–æ–≥–æ–¥–∞ —Ö–º–∞—Ä–Ω–∞ —ñ –ø—Ä–æ—Ö–æ–ª–æ–¥–Ω–∞, –∞–ª–µ –≤—Å—ñ —â–∞—Å–ª–∏–≤—ñ."
    },
    choices: [
      { text: "Sing along to the music.", nextScene: 'sing_along' },
      { text: "Look out for road signs.", nextScene: 'road_sign' }
    ]
  },

  'choose_scenic': {
    text: {
      en: "You decide to take coastal road B9. Maya agrees: 'Good idea. It's longer, but maybe safer than the highway with the hailstorm warning.' Leo finds the route on the GPS.",
      // Focus: comparative 'safer than', weather vocab
      ua: "–í–∏ –≤–∏—Ä—ñ—à—É—î—Ç–µ —ó—Ö–∞—Ç–∏ –ø—Ä–∏–±–µ—Ä–µ–∂–Ω–æ—é –¥–æ—Ä–æ–≥–æ—é B9. –ú–∞–π—è –ø–æ–≥–æ–¥–∂—É—î—Ç—å—Å—è: '–ì–∞—Ä–Ω–∞ —ñ–¥–µ—è. –í–æ–Ω–∞ –¥–æ–≤—à–∞, –∞–ª–µ, –º–æ–∂–ª–∏–≤–æ, –±–µ–∑–ø–µ—á–Ω—ñ—à–∞, –Ω—ñ–∂ —à–æ—Å–µ –∑ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è–º –ø—Ä–æ –≥—Ä–∞–¥.' –õ–µ–æ –∑–Ω–∞—Ö–æ–¥–∏—Ç—å –º–∞—Ä—à—Ä—É—Ç –Ω–∞ GPS."
    },
    choices: [
      { text: "Drive carefully along the coast.", nextScene: 'road_sign' }
    ]
  },

   'sing_along': {
     text: {
       en: "Everyone sings loudly. It feels like the festival has already started! After the song, you pay attention to the road again.",
       ua: "–í—Å—ñ –≥–æ–ª–æ—Å–Ω–æ —Å–ø—ñ–≤–∞—é—Ç—å. –ó–¥–∞—î—Ç—å—Å—è, —Ñ–µ—Å—Ç–∏–≤–∞–ª—å –≤–∂–µ –ø–æ—á–∞–≤—Å—è! –ü—ñ—Å–ª—è –ø—ñ—Å–Ω—ñ —Ç–∏ –∑–Ω–æ–≤—É –∑–≤–µ—Ä—Ç–∞—î—à —É–≤–∞–≥—É –Ω–∞ –¥–æ—Ä–æ–≥—É."
     },
     choices: [
       { text: "Look out for road signs.", nextScene: 'road_sign' }
     ]
   },

  /* ---------- 3. FIRST OBSTACLE ---------- */
  'road_sign': {
    text: {
      en: "You see a road sign: *Pedestrian crossing ahead*. You slow down. An old lady and her small dog are waiting on the pavement.",
      // Focus: road nouns
      ua: "–¢–∏ –±–∞—á–∏—à –¥–æ—Ä–æ–∂–Ω—ñ–π –∑–Ω–∞–∫: *–ü–æ–ø–µ—Ä–µ–¥—É –ø—ñ—à–æ—Ö—ñ–¥–Ω–∏–π –ø–µ—Ä–µ—Ö—ñ–¥*. –¢–∏ —Å–ø–æ–≤—ñ–ª—å–Ω—é—î—à—Å—è. –°—Ç–∞—Ä–µ–Ω—å–∫–∞ –ø–∞–Ω—ñ —Ç–∞ —ó—ó –º–∞–ª–µ–Ω—å–∫–∏–π –ø–µ—Å–∏–∫ —á–µ–∫–∞—é—Ç—å –Ω–∞ —Ç—Ä–æ—Ç—É–∞—Ä—ñ."
    },
    choices: [
      { text: "Stop and let them cross.", nextScene: 'good_deed' },
      { text: "Honk the horn quickly.", nextScene: 'bad_deed' }
    ]
  },

  'good_deed': {
    text: {
      en: "You stop. The lady smiles and waves. 'Thank you!' Maya says, 'That was kind.' Leo adds, 'Okay, let's carry on!'",
      // Focus: phrasal verb 'carry on'
      ua: "–¢–∏ –∑—É–ø–∏–Ω—è—î—à—Å—è. –ü–∞–Ω—ñ –ø–æ—Å–º—ñ—Ö–∞—î—Ç—å—Å—è —ñ –º–∞—Ö–∞—î. '–î—è–∫—É—é!' –ú–∞–π—è –∫–∞–∂–µ: '–¶–µ –±—É–ª–æ –ª—é–±'—è–∑–Ω–æ.' –õ–µ–æ –¥–æ–¥–∞—î: '–ì–∞—Ä–∞–∑–¥, –ø—Ä–æ–¥–æ–≤–∂—É–π–º–æ!'"
    },
    choices: [
      { text: "Drive towards the bridge.", nextScene: 'foggy_bridge' }
    ]
  },

  'bad_deed': {
    text: {
      en: "You honk. The dog gets scared and jumps! The lady looks upset. You feel a bit bad. 'Maybe honking wasn't the fastest way,' you think.",
      ua: "–¢–∏ —Å–∏–≥–Ω–∞–ª–∏—à. –°–æ–±–∞–∫–∞ –ª—è–∫–∞—î—Ç—å—Å—è —ñ –ø—ñ–¥—Å—Ç—Ä–∏–±—É—î! –ü–∞–Ω—ñ –≤–∏–≥–ª—è–¥–∞—î –∑–∞—Å–º—É—á–µ–Ω–æ—é. –¢–æ–±—ñ —Ç—Ä–æ—Ö–∏ —Å–æ—Ä–æ–º–Ω–æ. '–ú–æ–∂–ª–∏–≤–æ, —Å–∏–≥–Ω–∞–ª–∏—Ç–∏ –±—É–ª–æ –Ω–µ –Ω–∞–π—à–≤–∏–¥—à–∏–º —Å–ø–æ—Å–æ–±–æ–º,' - –¥—É–º–∞—î—à —Ç–∏."
    },
    choices: [
      { text: "Carry on driving.", nextScene: 'foggy_bridge' } // Focus: phrasal verb 'carry on'
    ]
  },

  /* ---------- 4. FOG & ICE ---------- */
  'foggy_bridge': {
    text: {
      en: "You approach a long metal bridge. Thick fog hangs in the air. It's getting colder. Could there be ice on the road?",
      // Focus: weather vocab, comparative 'colder'
      ua: "–í–∏ –Ω–∞–±–ª–∏–∂–∞—î—Ç–µ—Å—è –¥–æ –¥–æ–≤–≥–æ–≥–æ –º–µ—Ç–∞–ª–µ–≤–æ–≥–æ –º–æ—Å—Ç—É. –ì—É—Å—Ç–∏–π —Ç—É–º–∞–Ω –≤–∏—Å–∏—Ç—å —É –ø–æ–≤—ñ—Ç—Ä—ñ. –°—Ç–∞—î —Ö–æ–ª–æ–¥–Ω—ñ—à–µ. –ß–∏ –º–æ–∂–µ –±—É—Ç–∏ –ª—ñ–¥ –Ω–∞ –¥–æ—Ä–æ–∑—ñ?"
    },
    choices: [
      { text: "Drive slowly and carefully.", nextScene: 'ice_skid' },
      { text: "Drive faster to get through the fog quickly.", nextScene: 'skid_alarm' }
    ]
  },

  'ice_skid': {
    text: {
      en: "Good choice! You drive slowly. The van slips a tiny bit on some ice, but you control it easily. Maya sighs, 'Phew! That ice looked dangerous.'",
      // Focus: weather vocab
      ua: "–ì–∞—Ä–Ω–∏–π –≤–∏–±—ñ—Ä! –¢–∏ —ó–¥–µ—à –ø–æ–≤—ñ–ª—å–Ω–æ. –§—É—Ä–≥–æ–Ω —Ç—Ä–æ—Ö–∏ –∫–æ–≤–∑–∞—î –ø–æ –ª—å–æ–¥—É, –∞–ª–µ —Ç–∏ –ª–µ–≥–∫–æ –π–æ–≥–æ –∫–æ–Ω—Ç—Ä–æ–ª—é—î—à. –ú–∞–π—è –∑—ñ—Ç—Ö–∞—î: '–§—É—Ö! –¢–æ–π –ª—ñ–¥ –≤–∏–≥–ª—è–¥–∞–≤ –Ω–µ–±–µ–∑–ø–µ—á–Ω–æ.'"
    },
    choices: [
      { text: "You made it across the bridge!", nextScene: 'snack_stop' }
    ]
  },

  'skid_alarm': {
    text: {
      en: "You drive faster. Suddenly the van spins on hidden ice! *SCREECH!* Everyone shouts! Luckily, you don't crash. Leo says, 'Okay, okay! I'll drive slower now!'",
      // Focus: weather vocab, comparative 'slower'
      ua: "–¢–∏ —ó–¥–µ—à —à–≤–∏–¥—à–µ. –†–∞–ø—Ç–æ–º —Ñ—É—Ä–≥–æ–Ω –∑–∞–Ω–æ—Å–∏—Ç—å –Ω–∞ –ø—Ä–∏—Ö–æ–≤–∞–Ω–æ–º—É –ª—å–æ–¥—É! *–í–ï–†–ï–°–ö!* –í—Å—ñ –∫—Ä–∏—á–∞—Ç—å! –ù–∞ —â–∞—Å—Ç—è, –≤–∏ –Ω–µ —Ä–æ–∑–±–∏–ª–∏—Å—è. –õ–µ–æ –∫–∞–∂–µ: '–ì–∞—Ä–∞–∑–¥, –≥–∞—Ä–∞–∑–¥! –¢–µ–ø–µ—Ä —è –±—É–¥—É —ó—Ö–∞—Ç–∏ –ø–æ–≤—ñ–ª—å–Ω—ñ—à–µ!'"
    },
    choices: [
      { text: "Continue driving (more carefully!).", nextScene: 'snack_stop' }
    ]
  },

  /* ---------- 5. SNACK STOP ---------- */
  'snack_stop': {
    text: {
      en: "You see a roadside billboard: *World‚Äôs Best Hot Chocolate ‚Üí 200 m.* Everyone feels hungry and a bit cold after the icy bridge.",
      // Focus: road nouns, weather vocab
      ua: "–¢–∏ –±–∞—á–∏—à –ø—Ä–∏–¥–æ—Ä–æ–∂–Ω—ñ–π –±—ñ–ª–±–æ—Ä–¥: *–ù–∞–π–∫—Ä–∞—â–µ –≥–∞—Ä—è—á–µ –∫–∞–∫–∞–æ —É —Å–≤—ñ—Ç—ñ ‚Üí 200 –º.* –í—Å—ñ –∑–≥–æ–ª–æ–¥–Ω—ñ–ª–∏ —ñ —Ç—Ä–æ—Ö–∏ –∑–º–µ—Ä–∑–ª–∏ –ø—ñ—Å–ª—è –∫—Ä–∏–∂–∞–Ω–æ–≥–æ –º–æ—Å—Ç—É."
    },
    choices: [
      { text: "Stop for hot chocolate.", nextScene: 'hot_chocolate_bar' }, // Corrected scene name
      { text: "Carry on ‚Äì the weather looks bad.", nextScene: 'storm_warning' } // Focus: phrasal verb 'carry on'
    ]
  },

  'hot_chocolate_bar': { // Corrected scene name
    text: {
      en: "You stop at the small caf√©. It‚Äôs warm inside. You all get hot chocolate. Outside, the wind is picking up. Are those snowflakes?",
      // Focus: weather vocab
      ua: "–í–∏ –∑—É–ø–∏–Ω—è—î—Ç–µ—Å—è –±—ñ–ª—è –º–∞–ª–µ–Ω—å–∫–æ—ó –∫–∞–≤'—è—Ä–Ω—ñ. –í—Å–µ—Ä–µ–¥–∏–Ω—ñ —Ç–µ–ø–ª–æ. –í–∏ –≤—Å—ñ –±–µ—Ä–µ—Ç–µ –≥–∞—Ä—è—á–∏–π —à–æ–∫–æ–ª–∞–¥. –ù–∞–¥–≤–æ—Ä—ñ –ø—ñ–¥–Ω—ñ–º–∞—î—Ç—å—Å—è –≤—ñ—Ç–µ—Ä. –ù–µ–≤–∂–µ —Ü–µ —Å–Ω—ñ–∂–∏–Ω–∫–∏?"
    },
    choices: [
      { text: "Drink quickly and go.", nextScene: 'storm_warning' },
      { text: "Offer Maya your extra marshmallow.", nextScene: 'flirt_cocoa' }
    ]
  },

  'flirt_cocoa': {
    text: {
      en: "You offer Maya the marshmallow. She smiles, 'Thanks! That's very kind.' Leo clears his throat loudly. 'Ahem! Are we leaving soon?'",
      ua: "–¢–∏ –ø—Ä–æ–ø–æ–Ω—É—î—à –ú–∞–π—ó –∑–µ—Ñ—ñ—Ä–∫—É. –í–æ–Ω–∞ –ø–æ—Å–º—ñ—Ö–∞—î—Ç—å—Å—è: '–î—è–∫—É—é! –¶–µ –¥—É–∂–µ –ª—é–±'—è–∑–Ω–æ.' –õ–µ–æ –≥–æ–ª–æ—Å–Ω–æ –ø—Ä–æ–∫–∞—à–ª—é—î—Ç—å—Å—è. '–ö—Ö–º! –ú–∏ —Å–∫–æ—Ä–æ —ó–¥–µ–º–æ?'"
    },
    choices: [
      { text: "Yes, back to the van. Look at those clouds!", nextScene: 'storm_warning' }
    ]
  },

  /* ---------- 6. STORM & HAIL ---------- */
  'storm_warning': {
    text: {
      en: "You get back in the van. The sky is much darker now. Black clouds gather quickly. The wind picks up, and suddenly, *ping! ping!* small hailstones hit the roof! The radio weather report says: ‚ÄúWarning! Hailstorm developing near Pine Valley!‚Äù",
      // Focus: weather vocab (clouds, wind, hailstones, hailstorm)
      ua: "–í–∏ –ø–æ–≤–µ—Ä—Ç–∞—î—Ç–µ—Å—è –¥–æ —Ñ—É—Ä–≥–æ–Ω–∞. –ù–µ–±–æ —Ç–µ–ø–µ—Ä –Ω–∞–±–∞–≥–∞—Ç–æ —Ç–µ–º–Ω—ñ—à–µ. –ß–æ—Ä–Ω—ñ —Ö–º–∞—Ä–∏ —à–≤–∏–¥–∫–æ –∑–±–∏—Ä–∞—é—Ç—å—Å—è. –í—ñ—Ç–µ—Ä –ø–æ—Å–∏–ª—é—î—Ç—å—Å—è, —ñ —Ä–∞–ø—Ç–æ–º, *–ø—ñ–Ω–≥! –ø—ñ–Ω–≥!* –º–∞–ª–µ–Ω—å–∫—ñ –≥—Ä–∞–¥–∏–Ω–∏ –±'—é—Ç—å –ø–æ –¥–∞—Ö—É! –†–∞–¥—ñ–æ–ø—Ä–æ–≥–Ω–æ–∑ –ø–æ–≥–æ–¥–∏ –ø–æ–≤—ñ–¥–æ–º–ª—è—î: ¬´–£–≤–∞–≥–∞! –ü–æ–±–ª–∏–∑—É –ü–∞–π–Ω-–í–µ–ª–ª—ñ —Ä–æ–∑–≤–∏–≤–∞—î—Ç—å—Å—è –≥—Ä–∞–¥!¬ª"
    },
    choices: [
      { text: "Find shelter quickly! Look for a bridge.", nextScene: 'under_bridge' },
      { text: "Try to drive through it ‚Äì carry on!", nextScene: 'hail_damage' } // Focus: phrasal verb 'carry on'
    ]
  },

  'under_bridge': {
    text: {
      en: "You see an old stone bridge ahead and drive under it just as the hailstorm gets heavier. It's safer here, but water is rising on the road under the bridge ‚Äì a small flood is starting!",
      // Focus: weather/disaster vocab (hailstorm, flood), comparative 'heavier', adjective 'safer'
      ua: "–ü–æ–ø–µ—Ä–µ–¥—É –≤–∏–¥–Ω—ñ—î—Ç—å—Å—è —Å—Ç–∞—Ä–∏–π –∫–∞–º'—è–Ω–∏–π –º—ñ—Å—Ç, —ñ –≤–∏ –∑–∞—ó–∂–¥–∂–∞—î—Ç–µ –ø—ñ–¥ –Ω—å–æ–≥–æ —Å–∞–º–µ —Ç–æ–¥—ñ, –∫–æ–ª–∏ –≥—Ä–∞–¥ –ø–æ—Å–∏–ª—é—î—Ç—å—Å—è. –¢—É—Ç –±–µ–∑–ø–µ—á–Ω—ñ—à–µ, –∞–ª–µ –≤–æ–¥–∞ –Ω–∞ –¥–æ—Ä–æ–∑—ñ –ø—ñ–¥ –º–æ—Å—Ç–æ–º –ø—ñ–¥–Ω—ñ–º–∞—î—Ç—å—Å—è ‚Äì –ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –Ω–µ–≤–µ–ª–∏–∫–∞ –ø–æ–≤—ñ–Ω—å!"
    },
    choices: [
      { text: "Wait for the hailstorm to stop.", nextScene: 'after_hail' },
      { text: "This looks bad. Turn back?", nextScene: 'road_block_flood' }
    ]
  },

  'hail_damage': {
    text: {
      en: "You decide to carry on driving. Big mistake! The hailstones get bigger, like marbles! *CRACK!* A large hailstone hits the windscreen, making a crack. You can hardly see! Leo shouts, 'We must stop!'",
      // Focus: weather vocab (hailstones), comparative 'bigger'
      ua: "–í–∏ –≤–∏—Ä—ñ—à—É—î—Ç–µ –ø—Ä–æ–¥–æ–≤–∂—É–≤–∞—Ç–∏ —ó—Ö–∞—Ç–∏. –í–µ–ª–∏–∫–∞ –ø–æ–º–∏–ª–∫–∞! –ì—Ä–∞–¥–∏–Ω–∏ —Å—Ç–∞—é—Ç—å –±—ñ–ª—å—à–∏–º–∏, —è–∫ –∫—É–ª—å–∫–∏! *–¢–†–Ü–°–ö!* –í–µ–ª–∏–∫–∞ –≥—Ä–∞–¥–∏–Ω–∞ –≤–¥–∞—Ä—è—î –≤ –ª–æ–±–æ–≤–µ —Å–∫–ª–æ, —Ä–æ–±–ª—è—á–∏ —Ç—Ä—ñ—â–∏–Ω—É. –ú–∞–π–∂–µ –Ω—ñ—á–æ–≥–æ –Ω–µ –≤–∏–¥–Ω–æ! –õ–µ–æ –∫—Ä–∏—á–∏—Ç—å: '–¢—Ä–µ–±–∞ –∑—É–ø–∏–Ω–∏—Ç–∏—Å—è!'"
    },
    choices: [
      { text: "Pull over under some trees quickly.", nextScene: 'after_hail' }
    ]
  },

  'after_hail': {
    text: {
      en: "After ten noisy minutes, the hailstorm stops. Silence. The ground is covered in white hailstones. Maya looks out: ‚ÄúWow, it looks like winter, not spring!‚Äù The air feels freezing.",
      // Focus: weather vocab (hailstorm, winter, spring, freezing)
      ua: "–ü—ñ—Å–ª—è –¥–µ—Å—è—Ç–∏ –≥–∞–ª–∞—Å–ª–∏–≤–∏—Ö —Ö–≤–∏–ª–∏–Ω –≥—Ä–∞–¥ –ø—Ä–∏–ø–∏–Ω—è—î—Ç—å—Å—è. –¢–∏—à–∞. –ó–µ–º–ª—è –≤–∫—Ä–∏—Ç–∞ –±—ñ–ª–∏–º–∏ –≥—Ä–∞–¥–∏–Ω–∞–º–∏. –ú–∞–π—è –≤–∏–∑–∏—Ä–∞—î: ¬´–í–∞—É, —Å—Ö–æ–∂–µ –Ω–∞ –∑–∏–º—É, –∞ –Ω–µ –Ω–∞ –≤–µ—Å–Ω—É!¬ª –ü–æ–≤—ñ—Ç—Ä—è –∑–¥–∞—î—Ç—å—Å—è –¥—É–∂–µ —Ö–æ–ª–æ–¥–Ω–∏–º."
    },
    choices: [
      { text: "Check the van for damage.", nextScene: 'van_check' }
    ]
  },

  /* ---------- 7. DAMAGE & DETOUR ---------- */
  'van_check': {
    text: {
      en: "You check the van. The windscreen has a crack, but it seems okay to drive. Bad news: a message on the GPS shows the main road ahead is closed. The radio says a mudslide blocked it during the storm!",
      // Focus: disaster vocab (mudslide, storm)
      ua: "–í–∏ –ø–µ—Ä–µ–≤—ñ—Ä—è—î—Ç–µ —Ñ—É—Ä–≥–æ–Ω. –ù–∞ –ª–æ–±–æ–≤–æ–º—É —Å–∫–ª—ñ —î —Ç—Ä—ñ—â–∏–Ω–∞, –∞–ª–µ, –∑–¥–∞—î—Ç—å—Å—è, —ó—Ö–∞—Ç–∏ –º–æ–∂–Ω–∞. –ü–æ–≥–∞–Ω–∞ –Ω–æ–≤–∏–Ω–∞: –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–∞ GPS –ø–æ–∫–∞–∑—É—î, —â–æ –≥–æ–ª–æ–≤–Ω–∞ –¥–æ—Ä–æ–≥–∞ –ø–æ–ø–µ—Ä–µ–¥—É –∑–∞–∫—Ä–∏—Ç–∞. –ü–æ —Ä–∞–¥—ñ–æ –∫–∞–∂—É—Ç—å, —â–æ —ó—ó –ø–µ—Ä–µ–∫—Ä–∏–≤ —Å–µ–ª–µ–≤–∏–π –∑—Å—É–≤ –ø—ñ–¥ —á–∞—Å —à—Ç–æ—Ä–º—É!"
    },
    choices: [
      { text: "Follow the official police detour.", nextScene: 'detour_valley' },
      { text: "Look for a short-cut on the map.", nextScene: 'mountain_track_choice' }
    ]
  },

  'road_block_flood': {
    text: {
      en: "You turn back from the flooding under the bridge. You reach the highway again, but see flashing police lights. A police officer stops you. 'Sorry, road closed ahead ‚Äì flood damage. You need to take the detour through Pine Valley.'",
      // Focus: disaster vocab (flood)
      ua: "–í–∏ –ø–æ–≤–µ—Ä—Ç–∞—î—Ç–µ –Ω–∞–∑–∞–¥ –≤—ñ–¥ –∑–∞—Ç–æ–ø–ª–µ–Ω–Ω—è –ø—ñ–¥ –º–æ—Å—Ç–æ–º. –í–∏ –∑–Ω–æ–≤—É –≤–∏—ó–∂–¥–∂–∞—î—Ç–µ –Ω–∞ —à–æ—Å–µ, –∞–ª–µ –±–∞—á–∏—Ç–µ –º–∏–≥–æ—Ç–ª–∏–≤—ñ –ø–æ–ª—ñ—Ü–µ–π—Å—å–∫—ñ –≤–æ–≥–Ω—ñ. –ü–æ–ª—ñ—Ü–µ–π—Å—å–∫–∏–π –∑—É–ø–∏–Ω—è—î –≤–∞—Å. '–í–∏–±–∞—á—Ç–µ, –¥–æ—Ä–æ–≥–∞ –ø–æ–ø–µ—Ä–µ–¥—É –∑–∞–∫—Ä–∏—Ç–∞ ‚Äì –ø–æ—à–∫–æ–¥–∂–µ–Ω–Ω—è —á–µ—Ä–µ–∑ –ø–æ–≤—ñ–Ω—å. –í–∞–º –ø–æ—Ç—Ä—ñ–±–Ω–æ —ó—Ö–∞—Ç–∏ –æ–±'—ó–∑–¥–æ–º —á–µ—Ä–µ–∑ –ü–∞–π–Ω-–í–µ–ª–ª—ñ.'"
    },
    choices: [
      { text: "Okay, take the Pine Valley detour.", nextScene: 'detour_valley' }
    ]
  },

  /* ---------- 8. DUSK IN THE VALLEY ---------- */
  'detour_valley': {
    text: {
      en: "You take the detour into Pine Valley. The road is narrow, with tall pine trees on both sides. It's getting dark quickly here, much darker than on the open highway. The air smells fresh and cool after the rain.",
      // Focus: comparative 'darker than', weather 'cool', 'rain'
      ua: "–í–∏ —ó–¥–µ—Ç–µ –æ–±'—ó–∑–¥–æ–º —É –ü–∞–π–Ω-–í–µ–ª–ª—ñ. –î–æ—Ä–æ–≥–∞ –≤—É–∑—å–∫–∞, –∑ –≤–∏—Å–æ–∫–∏–º–∏ —Å–æ—Å–Ω–∞–º–∏ –ø–æ –æ–±–∏–¥–≤–∞ –±–æ–∫–∏. –¢—É—Ç —à–≤–∏–¥–∫–æ —Ç–µ–º–Ω—ñ—î, –Ω–∞–±–∞–≥–∞—Ç–æ —Ç–µ–º–Ω—ñ—à–µ, –Ω—ñ–∂ –Ω–∞ –≤—ñ–¥–∫—Ä–∏—Ç–æ–º—É —à–æ—Å–µ. –ü–æ–≤—ñ—Ç—Ä—è –ø–∞—Ö–Ω–µ —Å–≤—ñ–∂—ñ—Å—Ç—é —ñ –ø—Ä–æ—Ö–æ–ª–æ–¥–æ—é –ø—ñ—Å–ª—è –¥–æ—â—É."
    },
    choices: [
      { text: "Turn on the headlights and carry on.", nextScene: 'deer_alert' }, // Focus: phrasal verb 'carry on'
      { text: "It's late. Suggest finding a place to stop.", nextScene: 'camp_spot_idea' }
    ]
  },

  'mountain_track_choice': {
    text: {
      en: "Leo looks at an old paper map. 'There's a small mountain track here. It looks steeper, but maybe faster than the long detour?' Maya says, 'Mountain tracks can be hazardous after storms.'",
      // Focus: comparative 'steeper', 'faster', adjective 'hazardous'
      ua: "–õ–µ–æ –¥–∏–≤–∏—Ç—å—Å—è –Ω–∞ —Å—Ç–∞—Ä—É –ø–∞–ø–µ—Ä–æ–≤—É –∫–∞—Ä—Ç—É. '–¢—É—Ç —î –Ω–µ–≤–µ–ª–∏–∫–∞ –≥—ñ—Ä—Å—å–∫–∞ —Å—Ç–µ–∂–∫–∞. –í–æ–Ω–∞ –≤–∏–≥–ª—è–¥–∞—î –∫—Ä—É—Ç—ñ—à–æ—é, –∞–ª–µ, –º–æ–∂–ª–∏–≤–æ, —à–≤–∏–¥—à–∞, –Ω—ñ–∂ –¥–æ–≤–≥–∏–π –æ–±'—ó–∑–¥?' –ú–∞–π—è –∫–∞–∂–µ: '–ì—ñ—Ä—Å—å–∫—ñ —Å—Ç–µ–∂–∫–∏ –º–æ–∂—É—Ç—å –±—É—Ç–∏ –Ω–µ–±–µ–∑–ø–µ—á–Ω–∏–º–∏ –ø—ñ—Å–ª—è —à—Ç–æ—Ä–º—ñ–≤.'"
    },
    choices: [
      { text: "Try the mountain track (risky).", nextScene: 'mountain_track_stuck' },
      { text: "Take the safer detour.", nextScene: 'detour_valley' } // Focus: comparative 'safer'
    ]
  },

  'mountain_track_stuck': {
    text: {
      en: "You turn onto the narrow mountain track. It is very steep and muddy from the rain and melting hail. Suddenly, the van's wheels spin... and sink into deep, soft mud! You are stuck!",
      // Focus: weather/disaster vocab (muddy, rain, hail)
      ua: "–í–∏ –∑–≤–µ—Ä—Ç–∞—î—Ç–µ –Ω–∞ –≤—É–∑—å–∫—É –≥—ñ—Ä—Å—å–∫—É —Å—Ç–µ–∂–∫—É. –í–æ–Ω–∞ –¥—É–∂–µ –∫—Ä—É—Ç–∞ —ñ –±–∞–≥–Ω–∏—Å—Ç–∞ –≤—ñ–¥ –¥–æ—â—É —Ç–∞ —Ç–∞–ª–æ–≥–æ –≥—Ä–∞–¥—É. –†–∞–ø—Ç–æ–º –∫–æ–ª–µ—Å–∞ —Ñ—É—Ä–≥–æ–Ω–∞ –ø—Ä–æ–±—É–∫—Å–æ–≤—É—é—Ç—å... —ñ –≥—Ä—É–∑–Ω—É—Ç—å —É –≥–ª–∏–±–æ–∫—ñ–π –º'—è–∫—ñ–π –±–∞–≥–Ω—é—Ü—ñ! –í–∏ –∑–∞—Å—Ç—Ä—è–≥–ª–∏!"
    },
    choices: [
      { text: "Try to call for help (check phone signal).", nextScene: 'no_signal' },
      { text: "Try to dig the van out.", nextScene: 'dig_out' }
    ]
  },

  /* ---------- 9. WILDLIFE / GETTING UNSTUCK ---------- */
  'deer_alert': {
    text: {
      en: "You carry on driving through the dark valley. Suddenly, two bright eyes reflect in your headlights! A huge deer stands in the middle of the road! Leo brakes hard. The van stops just in time. Wow!",
      ua: "–í–∏ –ø—Ä–æ–¥–æ–≤–∂—É—î—Ç–µ —ó—Ö–∞—Ç–∏ —Ç–µ–º–Ω–æ—é –¥–æ–ª–∏–Ω–æ—é. –†–∞–ø—Ç–æ–º —É —Å–≤—ñ—Ç–ª—ñ —Ñ–∞—Ä –≤—ñ–¥–±–∏–≤–∞—é—Ç—å—Å—è –¥–≤–∞ —è—Å–∫—Ä–∞–≤—ñ –æ–∫–∞! –í–µ–ª–∏—á–µ–∑–Ω–∏–π –æ–ª–µ–Ω—å —Å—Ç–æ—ó—Ç—å –ø–æ—Å–µ—Ä–µ–¥ –¥–æ—Ä–æ–≥–∏! –õ–µ–æ —Ä—ñ–∑–∫–æ –≥–∞–ª—å–º—É—î. –§—É—Ä–≥–æ–Ω –∑—É–ø–∏–Ω—è—î—Ç—å—Å—è –≤ –æ—Å—Ç–∞–Ω–Ω—ñ–π –º–æ–º–µ–Ω—Ç. –í–∞—É!"
    },
    choices: [
      { text: "Wait for the deer to move.", nextScene: 'deer_moves' },
      { text: "Honk the horn gently.", nextScene: 'deer_moves' }
    ]
  },

   'deer_moves': {
     text: {
       en: "After a moment, the deer calmly walks into the forest. Everyone breathes again. 'That was close!' says Sam. 'Let's find somewhere to stop for the night. It's not safe to drive here in the dark.'",
       // Focus: adjective 'safe'
       ua: "–ó–∞ –º–∏—Ç—å –æ–ª–µ–Ω—å —Å–ø–æ–∫—ñ–π–Ω–æ –∑–∞—Ö–æ–¥–∏—Ç—å —É –ª—ñ—Å. –£—Å—ñ –∑–Ω–æ–≤—É –¥–∏—Ö–∞—é—Ç—å. '–õ–µ–¥—å –Ω–µ —Å—Ç–∞–ª–æ—Å—è!' - –∫–∞–∂–µ –°–µ–º. '–î–∞–≤–∞–π—Ç–µ –∑–Ω–∞–π–¥–µ–º–æ –¥–µ—Å—å –º—ñ—Å—Ü–µ –¥–ª—è –∑—É–ø–∏–Ω–∫–∏ –Ω–∞ –Ω—ñ—á. –¢—É—Ç –Ω–µ–±–µ–∑–ø–µ—á–Ω–æ —ó—Ö–∞—Ç–∏ –≤ —Ç–µ–º—Ä—è–≤—ñ.'"
     },
     choices: [
       { text: "Agree. Look for a safe spot.", nextScene: 'camp_spot_idea' }
     ]
   },

  'no_signal': {
    text: {
      en: "You all check your phones. Zero bars. 'No service' displayed on every screen. You can't call for assistance. Sam looks worried. 'What do we do now? Should we give up?' Leo shakes his head. 'No! We need to come up with a plan!'",
      // Focus: phrasal verbs 'give up', 'come up with'
      ua: "–í–∏ –≤—Å—ñ –ø–µ—Ä–µ–≤—ñ—Ä—è—î—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω–∏. –ù—É–ª—å –ø–æ–¥—ñ–ª–æ–∫. '–ù–µ–º–∞—î –º–µ—Ä–µ–∂—ñ' –Ω–∞ –∫–æ–∂–Ω–æ–º—É –µ–∫—Ä–∞–Ω—ñ. –í–∏ –Ω–µ –º–æ–∂–µ—Ç–µ –≤–∏–∫–ª–∏–∫–∞—Ç–∏ –¥–æ–ø–æ–º–æ–≥—É. –°–µ–º –≤–∏–≥–ª—è–¥–∞—î —Å—Ç—É—Ä–±–æ–≤–∞–Ω–∏–º. '–©–æ –Ω–∞–º —Ç–µ–ø–µ—Ä —Ä–æ–±–∏—Ç–∏? –ú–æ–∂–µ, –∑–¥–∞–º–æ—Å—è?' –õ–µ–æ —Ö–∏—Ç–∞—î –≥–æ–ª–æ–≤–æ—é. '–ù—ñ! –ù–∞–º —Ç—Ä–µ–±–∞ –≤–∏–≥–∞–¥–∞—Ç–∏ –ø–ª–∞–Ω!'"
    },
    choices: [
      { text: "Suggest climbing the hill for signal.", nextScene: 'signal_hill' },
      { text: "Suggest digging the van out.", nextScene: 'dig_out' }
    ]
  },

  'dig_out': {
    text: {
      en: "You find shovels in the back of the van. Everyone starts digging. The mud is thick and heavy. It's hard work, much harder than packing the van! But after 30 minutes, the wheels are free!",
      // Focus: comparative 'harder than'
      ua: "–í–∏ –∑–Ω–∞—Ö–æ–¥–∏—Ç–µ –ª–æ–ø–∞—Ç–∏ –≤ –∑–∞–¥–Ω—ñ–π —á–∞—Å—Ç–∏–Ω—ñ —Ñ—É—Ä–≥–æ–Ω–∞. –í—Å—ñ –ø–æ—á–∏–Ω–∞—é—Ç—å –∫–æ–ø–∞—Ç–∏. –ë–∞–≥–Ω—é–∫–∞ –≥—É—Å—Ç–∞ —ñ –≤–∞–∂–∫–∞. –¶–µ –≤–∞–∂–∫–∞ —Ä–æ–±–æ—Ç–∞, –Ω–∞–±–∞–≥–∞—Ç–æ –≤–∞–∂—á–∞, –Ω—ñ–∂ –ø–∞–∫—É–≤–∞—Ç–∏ —Ñ—É—Ä–≥–æ–Ω! –ê–ª–µ —á–µ—Ä–µ–∑ 30 —Ö–≤–∏–ª–∏–Ω –∫–æ–ª–µ—Å–∞ –≤—ñ–ª—å–Ω—ñ!"
    },
    choices: [
      { text: "Try driving forward on the track.", nextScene: 'avalanche_risk' },
      { text: "Carefully turn back to the main road/detour.", nextScene: 'valley_fall' }
    ]
  },

  'signal_hill': {
    text: {
      en: "You and Maya decide to climb the nearest hill. It's steep and slippery. At the top, Maya's phone picks up one tiny bar of signal! You quickly call roadside assistance. They say they can send a truck, but it will take three hours because of the road conditions.",
      ua: "–¢–∏ —ñ –ú–∞–π—è –≤–∏—Ä—ñ—à—É—î—Ç–µ –ø—ñ–¥–Ω—è—Ç–∏—Å—è –Ω–∞ –Ω–∞–π–±–ª–∏–∂—á–∏–π –ø–∞–≥–æ—Ä–±. –í—ñ–Ω –∫—Ä—É—Ç–∏–π —ñ —Å–ª–∏–∑—å–∫–∏–π. –ù–∞ –≤–µ—Ä—à–∏–Ω—ñ —Ç–µ–ª–µ—Ñ–æ–Ω –ú–∞–π—ó –ª–æ–≤–∏—Ç—å –æ–¥–Ω—É –∫—Ä–∏—Ö—ñ—Ç–Ω—É –ø–æ–¥—ñ–ª–∫—É —Å–∏–≥–Ω–∞–ª—É! –í–∏ —à–≤–∏–¥–∫–æ –¥–∑–≤–æ–Ω–∏—Ç–µ –≤ –¥–æ—Ä–æ–∂–Ω—é —Å–ª—É–∂–±—É. –í–æ–Ω–∏ –∫–∞–∂—É—Ç—å, —â–æ –º–æ–∂—É—Ç—å –Ω–∞–¥—ñ—Å–ª–∞—Ç–∏ –µ–≤–∞–∫—É–∞—Ç–æ—Ä, –∞–ª–µ —Ü–µ –∑–∞–π–º–µ —Ç—Ä–∏ –≥–æ–¥–∏–Ω–∏ —á–µ—Ä–µ–∑ –¥–æ—Ä–æ–∂–Ω—ñ —É–º–æ–≤–∏."
    },
    choices: [
      { text: "Go back and try digging while waiting.", nextScene: 'dig_out' },
      { text: "Wait three hours for the tow truck.", nextScene: 'wait_truck' }
    ]
  },

  'wait_truck': {
    text: {
      en: "You decide to wait. It gets colder and darker. Three hours feels like forever. The tow truck finally arrives, but by the time you are back on the road, you know you have missed the first day of WaveFest. <span class='game-over'>MISSION FAILED (Too Late)</span>",
      // Focus: comparative 'colder', 'darker'
      ua: "–í–∏ –≤–∏—Ä—ñ—à—É—î—Ç–µ —á–µ–∫–∞—Ç–∏. –°—Ç–∞—î —Ö–æ–ª–æ–¥–Ω—ñ—à–µ —ñ —Ç–µ–º–Ω—ñ—à–µ. –¢—Ä–∏ –≥–æ–¥–∏–Ω–∏ –∑–¥–∞—é—Ç—å—Å—è –≤—ñ—á–Ω—ñ—Å—Ç—é. –ï–≤–∞–∫—É–∞—Ç–æ—Ä –Ω–∞—Ä–µ—à—Ç—ñ –ø—Ä–∏—ó–∂–¥–∂–∞—î, –∞–ª–µ –¥–æ —Ç–æ–≥–æ —á–∞—Å—É, —è–∫ –≤–∏ –ø–æ–≤–µ—Ä—Ç–∞—î—Ç–µ—Å—è –Ω–∞ –¥–æ—Ä–æ–≥—É, –≤–∏ –∑–Ω–∞—î—Ç–µ, —â–æ –ø—Ä–æ–ø—É—Å—Ç–∏–ª–∏ –ø–µ—Ä—à–∏–π –¥–µ–Ω—å WaveFest. <span class='game-over'>–ú–Ü–°–Ü–Ø –ü–†–û–í–ê–õ–ï–ù–ê (–ó–∞–Ω–∞–¥—Ç–æ –ø—ñ–∑–Ω–æ)</span>"
    },
    choices: [
      { text: "Restart?", nextScene: 'start' }
    ]
  },

  /* ---------- 10. CAMPING SPOT IDEA ---------- */
  'camp_spot_idea': {
    text: {
      en: "Driving slowly, you spot a closed petrol station with a flat, dry area next to it under a lamp post. 'Let's stop here for the night,' suggests Maya. 'It looks safer than driving in this dark valley.'",
      // Focus: comparative 'safer than'
      ua: "–á–¥—É—á–∏ –ø–æ–≤—ñ–ª—å–Ω–æ, –≤–∏ –ø–æ–º—ñ—á–∞—î—Ç–µ –∑–∞—á–∏–Ω–µ–Ω—É –∑–∞–ø—Ä–∞–≤–∫—É –∑ —Ä—ñ–≤–Ω–æ—é, —Å—É—Ö–æ—é –¥—ñ–ª—è–Ω–∫–æ—é –ø–æ—Ä—É—á –ø—ñ–¥ –ª—ñ—Ö—Ç–∞—Ä–Ω–∏–º —Å—Ç–æ–≤–ø–æ–º. '–î–∞–≤–∞–π—Ç–µ –∑—É–ø–∏–Ω–∏–º–æ—Å—è —Ç—É—Ç –Ω–∞ –Ω—ñ—á,' - –ø—Ä–æ–ø–æ–Ω—É—î –ú–∞–π—è. '–¶–µ –≤–∏–≥–ª—è–¥–∞—î –±–µ–∑–ø–µ—á–Ω—ñ—à–µ, –Ω—ñ–∂ —ó—Ö–∞—Ç–∏ —Ü—ñ—î—é —Ç–µ–º–Ω–æ—é –¥–æ–ª–∏–Ω–æ—é.'"
    },
    choices: [
      { text: "Good idea. Park the van.", nextScene: 'camp_spot_parked' }
    ]
  },

  'camp_spot_parked': {
    text: {
      en: "You park the van. It's quiet here, except for the wind in the pines. You feel tired after the long, difficult day.",
      ua: "–í–∏ –ø–∞—Ä–∫—É—î—Ç–µ —Ñ—É—Ä–≥–æ–Ω. –¢—É—Ç —Ç–∏—Ö–æ, —Ç—ñ–ª—å–∫–∏ –≤—ñ—Ç–µ—Ä —à—É–º–∏—Ç—å —É —Å–æ—Å–Ω–∞—Ö. –í–∏ –≤—ñ–¥—á—É–≤–∞—î—Ç–µ –≤—Ç–æ–º—É –ø—ñ—Å–ª—è –¥–æ–≤–≥–æ–≥–æ, –≤–∞–∂–∫–æ–≥–æ –¥–Ω—è."
    },
    choices: [
      { text: "Make a small campfire to warm up.", nextScene: 'campfire_romance' },
      { text: "Too tired. Sleep in the van.", nextScene: 'sleep_van' }
    ]
  },

  /* ---------- 10A. CAMPFIRE & LOVE ---------- */
  'campfire_romance': {
    text: {
      en: "You make a small campfire. The flames dance. The air is cool, and the stars look brighter than city lights. Maya sits close to you. 'This trip is difficult,' she says, 'but we didn't give up!'",
      // Focus: comparative 'brighter than', phrasal verb 'give up'
      ua: "–í–∏ —Ä–æ–∑–ø–∞–ª—é—î—Ç–µ –Ω–µ–≤–µ–ª–∏–∫–µ –±–∞–≥–∞—Ç—Ç—è. –ü–æ–ª—É–º‚Äô—è —Ç–∞–Ω—Ü—é—î. –ü–æ–≤—ñ—Ç—Ä—è –ø—Ä–æ—Ö–æ–ª–æ–¥–Ω–µ, –∞ –∑–æ—Ä—ñ –≤–∏–≥–ª—è–¥–∞—é—Ç—å —è—Å–∫—Ä–∞–≤—ñ—à–∏–º–∏, –Ω—ñ–∂ –º—ñ—Å—å–∫—ñ –≤–æ–≥–Ω—ñ. –ú–∞–π—è —Å—ñ–¥–∞—î –±–ª–∏–∑—å–∫–æ –¥–æ —Ç–µ–±–µ. ¬´–¶—è –ø–æ–¥–æ—Ä–æ–∂ –≤–∞–∂–∫–∞,¬ª - –∫–∞–∂–µ –≤–æ–Ω–∞, - ¬´–∞–ª–µ –º–∏ –Ω–µ –∑–¥–∞–ª–∏—Å—è!¬ª"
    },
    choices: [
      { text: "Agree: 'Yes, we'll carry on!'", nextScene: 'dawn_rain' }, // Focus: phrasal verb 'carry on'
      { text: "Say 'It's warmer near the fire.'", nextScene: 'hand_hold' }
    ]
  },

  'sleep_van': {
    text: {
      en: "Everyone is too tired for a fire. You all try to sleep in the van. It's not very comfortable. You think about the festival ‚Äì it feels far away.",
      ua: "–í—Å—ñ –∑–∞–Ω–∞–¥—Ç–æ –≤—Ç–æ–º–ª–µ–Ω—ñ –¥–ª—è –±–∞–≥–∞—Ç—Ç—è. –í–∏ –≤—Å—ñ –Ω–∞–º–∞–≥–∞—î—Ç–µ—Å—è –∑–∞—Å–Ω—É—Ç–∏ —É —Ñ—É—Ä–≥–æ–Ω—ñ. –¶–µ –Ω–µ –¥—É–∂–µ –∑—Ä—É—á–Ω–æ. –¢–∏ –¥—É–º–∞—î—à –ø—Ä–æ —Ñ–µ—Å—Ç–∏–≤–∞–ª—å ‚Äì –≤—ñ–Ω –∑–¥–∞—î—Ç—å—Å—è —Ç–∞–∫–∏–º –¥–∞–ª–µ–∫–∏–º."
    },
    choices: [
      { text: "Finally fall asleep.", nextScene: 'dawn_rain' }
    ]
  },

  'hand_hold': {
    text: {
      en: "Maya smiles. 'Yes, it is warmer here.' You both look at the fire. Leo coughs. 'Time to sleep soon? We need to wake up early!'",
      // Focus: comparative 'warmer', phrasal verb 'wake up'
      ua: "–ú–∞–π—è –ø–æ—Å–º—ñ—Ö–∞—î—Ç—å—Å—è. '–¢–∞–∫, —Ç—É—Ç —Ç–µ–ø–ª—ñ—à–µ.' –í–∏ –æ–±–æ—î –¥–∏–≤–∏—Ç–µ—Å—è –Ω–∞ –≤–æ–≥–æ–Ω—å. –õ–µ–æ –∫–∞—à–ª—è—î. '–°–∫–æ—Ä–æ —Å–ø–∞—Ç–∏? –ù–∞–º —Ç—Ä–µ–±–∞ —Ä–∞–Ω–æ –ø—Ä–æ–∫–∏–¥–∞—Ç–∏—Å—è!'"
    },
    choices: [
      { text: "Okay, time to rest.", nextScene: 'dawn_rain' }
    ]
  },

  /* ---------- 11. DAWN & RAIN ---------- */
  'dawn_rain': {
    text: {
      en: "You wake up. Gentle rain is falling. It's softer than the hailstorm yesterday, but it's still cold. Everyone feels stiff. Leo checks the GPS: '120 km to WaveFest!'",
      // Focus: comparative 'softer than', weather vocab
      ua: "–¢–∏ –ø—Ä–æ–∫–∏–¥–∞—î—à—Å—è. –ô–¥–µ –ª–µ–≥–∫–∏–π –¥–æ—â. –í—ñ–Ω –º'—è–∫—à–∏–π, –Ω—ñ–∂ –≤—á–æ—Ä–∞—à–Ω—ñ–π –≥—Ä–∞–¥, –∞–ª–µ –≤—Å–µ —â–µ —Ö–æ–ª–æ–¥–Ω–æ. –í—Å—ñ –ø–æ—á—É–≤–∞—é—Ç—å—Å—è –∑–∞–¥–µ—Ä–µ–≤'—è–Ω—ñ–ª–∏–º–∏. –õ–µ–æ –ø–µ—Ä–µ–≤—ñ—Ä—è—î GPS: '120 –∫–º –¥–æ WaveFest!'"
    },
    choices: [
      { text: "Eat breakfast quickly and carry on.", nextScene: 'petrol_low' }, // Focus: phrasal verb 'carry on'
      { text: "Try to dry wet clothes first.", nextScene: 'clothes_dry' }
    ]
  },

  'clothes_dry': {
    text: {
      en: "You try to dry some clothes near the dying campfire. It uses up the last of the wood. The clothes are a bit drier, but you wasted time, and the van used petrol for heating.",
      // Focus: phrasal verb 'use up', comparative 'drier'
      ua: "–í–∏ –Ω–∞–º–∞–≥–∞—î—Ç–µ—Å—è –≤–∏—Å—É—à–∏—Ç–∏ –æ–¥—è–≥ –±—ñ–ª—è –∑–≥–∞—Å–∞—é—á–æ–≥–æ –±–∞–≥–∞—Ç—Ç—è. –¶–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î –æ—Å—Ç–∞–Ω–Ω—ñ –¥—Ä–æ–≤–∞. –û–¥—è–≥ —Ç—Ä–æ—Ö–∏ —Å—É—Ö—ñ—à–∏–π, –∞–ª–µ –≤–∏ –∑–º–∞—Ä–Ω—É–≤–∞–ª–∏ —á–∞—Å, —ñ —Ñ—É—Ä–≥–æ–Ω –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–≤ –±–µ–Ω–∑–∏–Ω –Ω–∞ –æ–±—ñ–≥—Ä—ñ–≤."
    },
    choices: [
      { text: "Okay, let's go now!", nextScene: 'petrol_low' }
    ]
  },

  /* ---------- 12. PETROL PROBLEM ---------- */
  'petrol_low': {
    text: {
      en: "Leo starts the van. Oh no! The fuel light is flashing red ‚Äì almost empty! The GPS shows the nearest petrol station is 15 km away, but the main road is still closed because of the flood.",
      // Focus: disaster vocab (flood)
      ua: "–õ–µ–æ –∑–∞–≤–æ–¥–∏—Ç—å —Ñ—É—Ä–≥–æ–Ω. –û –Ω—ñ! –Ü–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–∞–ª—å–Ω–æ–≥–æ –±–ª–∏–º–∞—î —á–µ—Ä–≤–æ–Ω–∏–º ‚Äì –º–∞–π–∂–µ –ø–æ—Ä–æ–∂–Ω—å–æ! GPS –ø–æ–∫–∞–∑—É—î, —â–æ –Ω–∞–π–±–ª–∏–∂—á–∞ –∑–∞–ø—Ä–∞–≤–∫–∞ –∑–∞ 15 –∫–º, –∞–ª–µ –≥–æ–ª–æ–≤–Ω–∞ –¥–æ—Ä–æ–≥–∞ –≤—Å–µ —â–µ –∑–∞–∫—Ä–∏—Ç–∞ —á–µ—Ä–µ–∑ –ø–æ–≤—ñ–Ω—å."
    },
    choices: [
      { text: "Take the official detour (safer).", nextScene: 'valley_fall' },
      { text: "Try the mountain track (riskier).", nextScene: 'mountain_track_stuck' }
    ]
  },

  /* ---------- 13. DETOUR CONTINUES / AVALANCHE ---------- */
  'valley_fall': {
    text: {
      en: "You carry on through Pine Valley. The road seems clear after the storm. Suddenly, you hear a loud rumble from the mountain above!",
      // Focus: phrasal verb 'carry on', disaster vocab (storm)
      ua: "–í–∏ –ø—Ä–æ–¥–æ–≤–∂—É—î—Ç–µ —ó—Ö–∞—Ç–∏ —á–µ—Ä–µ–∑ –ü–∞–π–Ω-–í–µ–ª–ª—ñ. –î–æ—Ä–æ–≥–∞ –∑–¥–∞—î—Ç—å—Å—è —á–∏—Å—Ç–æ—é –ø—ñ—Å–ª—è —à—Ç–æ—Ä–º—É. –†–∞–ø—Ç–æ–º –≤–∏ —á—É—î—Ç–µ –≥—É—á–Ω–∏–π –≥—É—Ä–∫—ñ—Ç –∑ –≥–æ—Ä–∏ –≤–≥–æ—Ä—ñ!"
    },
    choices: [
      { text: "What was that?", nextScene: 'avalanche_risk' }
    ]
  },

  'avalanche_risk': {
    text: {
      en: "An avalanche! Snow and rocks slide down the mountain, blocking the road behind you! You can't turn back now. The only way is forward.",
      // Focus: disaster vocab (avalanche)
      ua: "–õ–∞–≤–∏–Ω–∞! –°–Ω—ñ–≥ —ñ –∫–∞–º—ñ–Ω–Ω—è –∑—Å—É–≤–∞—é—Ç—å—Å—è –∑ –≥–æ—Ä–∏, –ø–µ—Ä–µ–∫—Ä–∏–≤–∞—é—á–∏ –¥–æ—Ä–æ–≥—É –ø–æ–∑–∞–¥—É –≤–∞—Å! –¢–µ–ø–µ—Ä –≤–∏ –Ω–µ –º–æ–∂–µ—Ç–µ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏ –Ω–∞–∑–∞–¥. –Ñ–¥–∏–Ω–∏–π —à–ª—è—Ö ‚Äì –≤–ø–µ—Ä–µ–¥."
    },
    choices: [
      { text: "Drive forward carefully on the narrow road.", nextScene: 'cliff_drive' }
    ]
  },

  'cliff_drive': {
    text: {
      en: "The road ahead is very narrow, right on the edge of a cliff! It looks more dangerous than the icy bridge. Drive very slowly.",
      // Focus: comparative 'more dangerous than'
      ua: "–î–æ—Ä–æ–≥–∞ –ø–æ–ø–µ—Ä–µ–¥—É –¥—É–∂–µ –≤—É–∑—å–∫–∞, –ø—Ä—è–º–æ –Ω–∞ –∫—Ä–∞—é —Å–∫–µ–ª—ñ! –í–æ–Ω–∞ –≤–∏–≥–ª—è–¥–∞—î –Ω–µ–±–µ–∑–ø–µ—á–Ω—ñ—à–æ—é, –Ω—ñ–∂ –∫—Ä–∏–∂–∞–Ω–∏–π –º—ñ—Å—Ç. –á–¥—å—Ç–µ –¥—É–∂–µ –ø–æ–≤—ñ–ª—å–Ω–æ."
    },
    choices: [
      { text: "Keep going slowly.", nextScene: 'bridge_quake' },
      { text: "Stop and check if the road is stable.", nextScene: 'road_crack' }
    ]
  },

  /* ---------- 14. BRIDGE & QUAKE ---------- */
  'road_crack': {
    text: {
      en: "You stop. As you look, a crack appears in the road! 'Quick! Drive!' shouts Maya. You drive fast just as some rocks fall behind you!",
      ua: "–í–∏ –∑—É–ø–∏–Ω—è—î—Ç–µ—Å—è. –ü–æ–∫–∏ –≤–∏ –¥–∏–≤–∏—Ç–µ—Å—è, –Ω–∞ –¥–æ—Ä–æ–∑—ñ –∑'—è–≤–ª—è—î—Ç—å—Å—è —Ç—Ä—ñ—â–∏–Ω–∞! '–®–≤–∏–¥–∫–æ! –á–¥—å!' - –∫—Ä–∏—á–∏—Ç—å –ú–∞–π—è. –í–∏ —à–≤–∏–¥–∫–æ —ó–¥–µ—Ç–µ —Å–∞–º–µ —Ç–æ–¥—ñ, –∫–æ–ª–∏ –ø–æ–∑–∞–¥—É –≤–∞—Å –ø–∞–¥–∞—î –∫–∞–º—ñ–Ω–Ω—è!"
    },
    choices: [
      { text: "Head for the big steel bridge.", nextScene: 'bridge_quake' }
    ]
  },

  'bridge_quake': {
    text: {
      en: "You reach a huge steel bridge. It looks very long. An engineer waves you to stop. 'Small earthquake damaged a cable,' he explains. 'Wait here. We let cars cross one by one.'",
      // Focus: disaster vocab (earthquake)
      ua: "–í–∏ –¥–æ—ó–∂–¥–∂–∞—î—Ç–µ –¥–æ –≤–µ–ª–∏—á–µ–∑–Ω–æ–≥–æ —Å—Ç–∞–ª–µ–≤–æ–≥–æ –º–æ—Å—Ç—É. –í—ñ–Ω –≤–∏–≥–ª—è–¥–∞—î –¥—É–∂–µ –¥–æ–≤–≥–∏–º. –Ü–Ω–∂–µ–Ω–µ—Ä –º–∞—Ö–∞—î –≤–∞–º –∑—É–ø–∏–Ω–∏—Ç–∏—Å—è. '–ù–µ–≤–µ–ª–∏–∫–∏–π –∑–µ–º–ª–µ—Ç—Ä—É—Å –ø–æ—à–∫–æ–¥–∏–≤ —Ç—Ä–æ—Å,' - –ø–æ—è—Å–Ω—é—î –≤—ñ–Ω. '–ß–µ–∫–∞–π—Ç–µ —Ç—É—Ç. –ú–∏ –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ –º–∞—à–∏–Ω–∏ –ø–æ –æ–¥–Ω—ñ–π.'"
    },
    choices: [
      { text: "Wait patiently.", nextScene: 'across_bridge' },
      { text: "Try to sneak past the queue.", nextScene: 'queue_jump' }
    ]
  },

  'queue_jump': {
    text: {
      en: "You try to drive past the waiting cars, but a guard stops you. 'Hey! Wait your turn! Bridge is closed down now for repair!' Oh no! You have to wait even longer.",
      // Focus: phrasal verb 'close down'
      ua: "–í–∏ –Ω–∞–º–∞–≥–∞—î—Ç–µ—Å—è –ø—Ä–æ—ó—Ö–∞—Ç–∏ –ø–æ–≤–∑ –º–∞—à–∏–Ω–∏, —â–æ —á–µ–∫–∞—é—Ç—å, –∞–ª–µ –æ—Ö–æ—Ä–æ–Ω–µ—Ü—å –∑—É–ø–∏–Ω—è—î –≤–∞—Å. '–ì–µ–π! –ß–µ–∫–∞–π—Ç–µ —Å–≤–æ—î—ó —á–µ—Ä–≥–∏! –ú—ñ—Å—Ç –∑–∞—Ä–∞–∑ –∑–∞–∫—Ä–∏–ª–∏ –Ω–∞ —Ä–µ–º–æ–Ω—Ç!' –û –Ω—ñ! –í–∞–º –¥–æ–≤–µ–¥–µ—Ç—å—Å—è —á–µ–∫–∞—Ç–∏ —â–µ –¥–æ–≤—à–µ."
    },
    choices: [
      { text: "Wait.", nextScene: 'across_bridge' }
    ]
  },

  'across_bridge': {
    text: {
      en: "Finally, it's your turn. You drive slowly onto the swaying bridge. It feels very high! You make it to the other side safely! Everyone cheers.",
      ua: "–ù–∞—Ä–µ—à—Ç—ñ, –≤–∞—à–∞ —á–µ—Ä–≥–∞. –í–∏ –ø–æ–≤—ñ–ª—å–Ω–æ –≤–∏—ó–∂–¥–∂–∞—î—Ç–µ –Ω–∞ –º—ñ—Å—Ç, —â–æ –≥–æ–π–¥–∞—î—Ç—å—Å—è. –ó–¥–∞—î—Ç—å—Å—è –¥—É–∂–µ –≤–∏—Å–æ–∫–æ! –í–∏ –±–µ–∑–ø–µ—á–Ω–æ –¥–æ–±–∏—Ä–∞—î—Ç–µ—Å—è –Ω–∞ —ñ–Ω—à–∏–π –±—ñ–∫! –í—Å—ñ —Ä–∞–¥—ñ—é—Ç—å."
    },
    choices: [
      { text: "Drive towards the city lights.", nextScene: 'city_smoke' }
    ]
  },

  /* ---------- 15. CITY OUTSKIRTS & FIRE ---------- */
  'city_smoke': {
    text: {
      en: "It's getting dark again. You see the lights of Coastville ahead. But wait! There is black smoke rising from the hill near the festival. The radio reports a small forest fire started by the thunderstorm!",
      // Focus: disaster vocab (forest fire, thunderstorm)
      ua: "–ó–Ω–æ–≤—É —Ç–µ–º–Ω—ñ—î. –ü–æ–ø–µ—Ä–µ–¥—É –≤–∏–¥–Ω–æ –≤–æ–≥–Ω—ñ –ö–æ—Å—Ç–≤—ñ–ª—è. –ê–ª–µ –∑–∞—á–µ–∫–∞–π—Ç–µ! –ó –ø–∞–≥–æ—Ä–±–∞ –±—ñ–ª—è —Ñ–µ—Å—Ç–∏–≤–∞–ª—é –ø—ñ–¥–Ω—ñ–º–∞—î—Ç—å—Å—è —á–æ—Ä–Ω–∏–π –¥–∏–º. –ü–æ —Ä–∞–¥—ñ–æ –ø–æ–≤—ñ–¥–æ–º–ª—è—é—Ç—å –ø—Ä–æ –Ω–µ–≤–µ–ª–∏–∫—É –ª—ñ—Å–æ–≤—É –ø–æ–∂–µ–∂—É, —Å–ø—Ä–∏—á–∏–Ω–µ–Ω—É –≥—Ä–æ–∑–æ—é!"
    },
    choices: [
      { text: "Go and see if the firefighters need help.", nextScene: 'help_firefighters' },
      { text: "Try to find a different road to the festival.", nextScene: 'side_road' }
    ]
  },

  'help_firefighters': {
    text: {
      en: "You drive closer. Firefighters are working hard. You offer to help. You carry water and look after some tired people. The fire chief thanks you. 'You kids are great! Here, take these VIP passes for the festival!'",
      // Focus: phrasal verb 'look after'
      ua: "–í–∏ –ø—ñ–¥'—ó–∂–¥–∂–∞—î—Ç–µ –±–ª–∏–∂—á–µ. –ü–æ–∂–µ–∂–Ω–∏–∫–∏ –≤–∞–∂–∫–æ –ø—Ä–∞—Ü—é—é—Ç—å. –í–∏ –ø—Ä–æ–ø–æ–Ω—É—î—Ç–µ –¥–æ–ø–æ–º–æ–≥—É. –í–∏ –Ω–æ—Å–∏—Ç–µ –≤–æ–¥—É —Ç–∞ –ø—ñ–∫–ª—É—î—Ç–µ—Å—è –ø—Ä–æ –≤—Ç–æ–º–ª–µ–Ω–∏—Ö –ª—é–¥–µ–π. –ù–∞—á–∞–ª—å–Ω–∏–∫ –ø–æ–∂–µ–∂–Ω–æ—ó —á–∞—Å—Ç–∏–Ω–∏ –¥—è–∫—É—î –≤–∞–º. '–í–∏ —á—É–¥–æ–≤—ñ –¥—ñ—Ç–∏! –û—Å—å, –≤—ñ–∑—å–º—ñ—Ç—å —Ü—ñ VIP-–ø–µ—Ä–µ–ø—É—Å—Ç–∫–∏ –Ω–∞ —Ñ–µ—Å—Ç–∏–≤–∞–ª—å!'"
    },
    choices: [
      // *** Added flag setting here ***
      { text: "Thank them and go to the festival gate!", setFlags: ['has_vip_pass'], nextScene: 'gate_line' }
    ]
  },

  'side_road': {
    text: {
      en: "You find a small side road. But many other cars had the same idea! The traffic is very slow. You might miss the start of the festival!",
      ua: "–í–∏ –∑–Ω–∞—Ö–æ–¥–∏—Ç–µ –Ω–µ–≤–µ–ª–∏–∫—É –±—ñ—á–Ω—É –¥–æ—Ä–æ–≥—É. –ê–ª–µ –±–∞–≥–∞—Ç–æ —ñ–Ω—à–∏—Ö –º–∞—à–∏–Ω –º–∞–ª–∏ —Ç—É –∂ —ñ–¥–µ—é! –†—É—Ö –¥—É–∂–µ –ø–æ–≤—ñ–ª—å–Ω–∏–π. –í–∏ –º–æ–∂–µ—Ç–µ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–∏ –ø–æ—á–∞—Ç–æ–∫ —Ñ–µ—Å—Ç–∏–≤–∞–ª—é!"
    },
    choices: [
      { text: "Park the van and walk.", nextScene: 'gate_line' },
      { text: "Give up, it's too late.", nextScene: 'generic_fail' } // Focus: phrasal verb 'give up'
    ]
  },

  /* ---------- 16. FESTIVAL GATE & FINALE ---------- */
  'gate_line': {
    text: {
      en: "You finally reach the festival gate! There's a huge crowd. The music is loud! It's raining again, but it's just a mild shower this time.",
      // Focus: weather vocab (rain, shower, mild)
      ua: "–í–∏ –Ω–∞—Ä–µ—à—Ç—ñ –¥—ñ—Å—Ç–∞—î—Ç–µ—Å—è –¥–æ –≤–æ—Ä—ñ—Ç —Ñ–µ—Å—Ç–∏–≤–∞–ª—é! –¢—É—Ç –≤–µ–ª–∏—á–µ–∑–Ω–∏–π –Ω–∞—Ç–æ–≤–ø. –ú—É–∑–∏–∫–∞ –≥—É—á–Ω–∞! –ó–Ω–æ–≤—É –π–¥–µ –¥–æ—â, –∞–ª–µ —Ü—å–æ–≥–æ —Ä–∞–∑—É —Ü–µ –ª–∏—à–µ –ª–µ–≥–∫–∞ –∑–ª–∏–≤–∞."
    },
    choices: [
      // Provide choice based on previous actions (VIP pass)
      { text: "Use the VIP passes!", checkRequired: 'has_vip_pass', nextScene: 'vip_entry' },
      { text: "Wait in the normal queue.", checkRequired: '!has_vip_pass', nextScene: 'regular_entry' },
      { text: "Wait in the normal queue (even with VIP pass).", checkRequired: 'has_vip_pass', nextScene: 'regular_entry' }
    ]
  },

  'vip_entry': {
    text: {
      en: "You show the VIP passes. The guard smiles. 'Welcome, heroes! Go right in!' You walk past the long queue. Inside, the lights and music are amazing!",
      ua: "–í–∏ –ø–æ–∫–∞–∑—É—î—Ç–µ VIP-–ø–µ—Ä–µ–ø—É—Å—Ç–∫–∏. –û—Ö–æ—Ä–æ–Ω–µ—Ü—å –ø–æ—Å–º—ñ—Ö–∞—î—Ç—å—Å—è. '–õ–∞—Å–∫–∞–≤–æ –ø—Ä–æ—Å–∏–º–æ, –≥–µ—Ä–æ—ó! –ü—Ä–æ—Ö–æ–¥—å—Ç–µ –ø—Ä—è–º–æ!' –í–∏ –ø—Ä–æ—Ö–æ–¥–∏—Ç–µ –ø–æ–≤–∑ –¥–æ–≤–≥—É —á–µ—Ä–≥—É. –í—Å–µ—Ä–µ–¥–∏–Ω—ñ —Å–≤—ñ—Ç–ª–æ —Ç–∞ –º—É–∑–∏–∫–∞ –¥–∏–≤–æ–≤–∏–∂–Ω—ñ!"
    },
    choices: [
      { text: "Go straight to the main stage!", nextScene: 'main_stage_arrival' }
    ]
  },

  'regular_entry': {
    text: {
      en: "You wait in the queue. It moves slowly. Finally, you are inside! Fireworks explode over the main stage!",
      ua: "–í–∏ —á–µ–∫–∞—î—Ç–µ –≤ —á–µ—Ä–∑—ñ. –í–æ–Ω–∞ —Ä—É—Ö–∞—î—Ç—å—Å—è –ø–æ–≤—ñ–ª—å–Ω–æ. –ù–∞—Ä–µ—à—Ç—ñ, –≤–∏ –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ! –ù–∞–¥ –≥–æ–ª–æ–≤–Ω–æ—é —Å—Ü–µ–Ω–æ—é –≤–∏–±—É—Ö–∞—é—Ç—å —Ñ–µ—î—Ä–≤–µ—Ä–∫–∏!"
    },
    choices: [
      { text: "Run towards the main stage!", nextScene: 'main_stage_arrival' }
    ]
  },

  'main_stage_arrival': {
    text: {
      en: "You reach the main stage just as Cloud‚Äë9 starts playing! The music is loud, the crowd is cheering. You look at Maya, she is smiling. You made it!",
      ua: "–í–∏ –¥–æ–±–∏—Ä–∞—î—Ç–µ—Å—è –¥–æ –≥–æ–ª–æ–≤–Ω–æ—ó —Å—Ü–µ–Ω–∏ —Å–∞–º–µ —Ç–æ–¥—ñ, –∫–æ–ª–∏ Cloud‚Äë9 –ø–æ—á–∏–Ω–∞—î –≥—Ä–∞—Ç–∏! –ú—É–∑–∏–∫–∞ –≥—É—á–Ω–∞, –Ω–∞—Ç–æ–≤–ø –∞–ø–ª–æ–¥—É—î. –¢–∏ –¥–∏–≤–∏—à—Å—è –Ω–∞ –ú–∞–π—é, –≤–æ–Ω–∞ –ø–æ—Å–º—ñ—Ö–∞—î—Ç—å—Å—è. –í–∏ —Ü–µ –∑—Ä–æ–±–∏–ª–∏!"
    },
    choices: [
      { text: "Enjoy the concert!", nextScene: 'end_success' }
    ]
  },

  /* ---------- END STATES ---------- */
  'end_success': {
    text: {
      en: "You survived the journey! Hailstorms, floods, mudslides, avalanches, maybe even a forest fire... but you didn't give up. You carried on! Now enjoy the festival! <span class='game-success'>ADVENTURE COMPLETE! WaveFest!</span>",
      // Focus: phrasal verbs 'give up', 'carry on', disaster vocab recap
      ua: "–í–∏ –ø–µ—Ä–µ–∂–∏–ª–∏ –ø–æ–¥–æ—Ä–æ–∂! –ì—Ä–∞–¥, –ø–æ–≤–µ–Ω—ñ, —Å–µ–ª–µ–≤—ñ –∑—Å—É–≤–∏, –ª–∞–≤–∏–Ω–∏, –º–æ–∂–ª–∏–≤–æ, –Ω–∞–≤—ñ—Ç—å –ª—ñ—Å–æ–≤–∞ –ø–æ–∂–µ–∂–∞... –∞–ª–µ –≤–∏ –Ω–µ –∑–¥–∞–ª–∏—Å—è. –í–∏ –ø—Ä–æ–¥–æ–≤–∂—É–≤–∞–ª–∏! –¢–µ–ø–µ—Ä –Ω–∞—Å–æ–ª–æ–¥–∂—É–π—Ç–µ—Å—å —Ñ–µ—Å—Ç–∏–≤–∞–ª–µ–º! <span class='game-success'>–ü–†–ò–ì–û–î–£ –ó–ê–í–ï–†–®–ï–ù–û! WaveFest!</span>"
    },
    choices: [
      { text: "Play Again?", nextScene: 'start' }
    ]
  },

  'generic_fail': {
    text: {
      en: "The journey was too difficult. Maybe you got stuck, ran out of time, or decided to give up. WaveFest will have to wait for another year. <span class='game-over'>MISSION FAILED</span>",
      // Focus: phrasal verb 'give up'
      ua: "–ü–æ–¥–æ—Ä–æ–∂ –±—É–ª–∞ –∑–∞–Ω–∞–¥—Ç–æ —Å–∫–ª–∞–¥–Ω–æ—é. –ú–æ–∂–ª–∏–≤–æ, –≤–∏ –∑–∞—Å—Ç—Ä—è–≥–ª–∏, —É –≤–∞—Å –∑–∞–∫—ñ–Ω—á–∏–≤—Å—è —á–∞—Å, –∞–±–æ –≤–∏ –≤–∏—Ä—ñ—à–∏–ª–∏ –∑–¥–∞—Ç–∏—Å—è. WaveFest –¥–æ–≤–µ–¥–µ—Ç—å—Å—è –ø–æ—á–µ–∫–∞—Ç–∏ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —Ä–æ–∫—É. <span class='game-over'>–ú–Ü–°–Ü–Æ –ü–†–û–í–ê–õ–ï–ù–û</span>"
    },
    choices: [
      { text: "Restart Adventure?", nextScene: 'start' }
    ]
  }
}; // End of gameData




// Vocabulary based on the provided lists for the WaveFest adventure
const vocabulary = [
  // Weather & Temperature
  "cloud", "cloudy", "snowflake", "frost", "shower", "sunny", "mist", "thunderstorm",
  "wind", "hailstorm", "fog", "ice", "freezing", "hot", "cool", "mild", "sweltering",
  "rain", // Added from game text
  "weather", "forecast", // Added from game text

  // Disasters
  "hurricane", "flood", "mudslide", "earthquake", "tsunami", "drought",
  "volcanic eruption", "forest fire", "avalanche", "storm", // Added from game text

  // Road / Place Nouns
  "road sign", "pedestrian crossing", "billboard", "shop sign", "traffic light",
  "bus stop", "pavement", "street corner", "lamp post", "fire hydrant", "highway",
  "route", "coast", "lighthouse", "bridge", "track", "valley", "cliff", "edge",
  "petrol station", "roadside", "city", "outskirts", "hill", "gate", "entrance",
  "car park", // Added from game text

  // People & Roles
  "pedestrian", "lady", "driver", // Added from game text
  "engineer", "guard", "police", "firefighter", "organiser", "staff", "electrician", // Added from game text
  "band", "crowd", // Added from game text

  // Objects & Things
  "van", "ticket", "snack", "bag", "engine", "GPS", "playlist", "dog", "leash",
  "tyre", "windscreen", "milkshake", "chocolate", "marshmallow", "roof", "radio",
  "hailstone", "crack", "traffic", "light", "shovel", "mud", "phone", "signal",
  "service", "tow truck", "thermometer", "cable", "asphalt", "suspension bridge",
  "water", "bolt", "smoke", "generator", "megaphone", "transformer", "fuel line",
  "duct tape", "VIP pass", "poncho", "cocoa", "fireworks", "confetti", "couch", // Added from game text

  // Actions & Events
  "festival", "trip", "music", "love", "mood", "warm-up", "view", "karma", "lesson",
  "crash", "solo", "break", "warning", "damage", "detour", "assistance", "rumble",
  "earthquake", "repair", "blackout", "power cut", "groan", "encore", "chorus", // Added from game text

  // Phrasal Verbs
  "look after", "wake up", "put off", "carry on", "give up", "come up with", "use up",
  "close down", "pack", "check", "throw", "jump", "head for", "start", "take off", // Added from game text
  "sing along", "slow down", "step onto", "brake", "wave", "honk", "spin", "slip", // Added from game text
  "stop", "apologise", "roll over", "skid", "control", "gasp", "yell", "race", // Added from game text
  "promise", "growl", "pick up", "rattle", "gather", "pull off", "block", "flash", // Added from game text
  "sink", "dig out", "climb", "pick up (signal)", "slide down", "hug", "shake", // Added from game text
  "power up", "sprint", "fall", "sway", "wave (cars)", "creep", "count", "make it", // Added from game text
  "cheer", "glow", "rise", "volunteer", "hand out", "carry", "miss", "build up", // Added from game text
  "run", "check (tickets)", "crawl", "boom", "hit", "jump", "cut off", "die", // Added from game text
  "sputter", "figure out", "tighten", "roar", "blaze", "save", "appear", "invite", // Added from game text

  // Misc Grammar Words (Comparatives, Adjectives, etc.)
  "bigger", "smaller", "hotter", "colder", "more dangerous", "safest", "longer",
  "more beautiful", "kinder", "faster", "slower", "darker", "steeper", "quieter",
  "brighter", "warmer", "softer", "lower", "heavier", "closer", "wider", "greater", // Added from game text
  "grey", "green", "old", "biggest", "possible", "hazardous", "excited", "awesome",
  "foggy", "sunny", "scenic", "bright", "gentle", "impatient", "kind", "thick",
  "icy", "long", "metal", "ghostly", "safe", "lucky", "coolest", "tiny", "warm",
  "odd", "sweet", "dark", "black", "marble-size", "worst", "stone", "fast", "white",
  "spring", "winter", "good", "bad", "small", "closed", "main", "flashing", "narrow",
  "soft", "stuck", "dry", "flat", "fancy", "awake", "farther", "stiff", "hopeful",
  "spare", "empty", "official", "unmarked", "nearby", "heavy", "free", "three hours",
  "wooden", "steel", "two football fields", "damaged", "patiently", "twice", "halfway",
  "loud", "huge", "neon", "sleepy", "steaming", "backup", "loose", "five minutes",
  "last", "off-key", "perfect", "happy", // Added from game text

  // Basic Function Words
  "a", "the", "is", "are", "was", "were", "and", "or", "but", "on", "in", "at", "of",
  "for", "with", "to", "from", "ahead", "onto", "under", "than", "like", "how", "what",
  "when", "where", "why", "if", "maybe", "suddenly", "anyway", "luckily", "already",
  "still", "just", "ever", "never", "ago", "later", "first", "now", "then", "only",
  "almost", "even", "also", "too", "very", "really", "together", "around", "behind",
  "across", "through", "towards", "above", "near", "next", "finally", "eventually",
  "carefully", "politely", "straight", "quickly", "slowly", "loudly", "gently", // Added adverbs
  "yes", "no", "‚úì" // Added from game text
];


// Translations for the WaveFest vocabulary (Ukrainian)
const vocabTranslations = {
  // Weather & Temperature
  "cloud": "—Ö–º–∞—Ä–∞", "cloudy": "—Ö–º–∞—Ä–Ω–∏–π", "snowflake": "—Å–Ω—ñ–∂–∏–Ω–∫–∞", "frost": "–ø–∞–º–æ—Ä–æ–∑—å/—ñ–Ω—ñ–π",
  "shower": "–∑–ª–∏–≤–∞ (–∫–æ—Ä–æ—Ç–∫–∞)", "sunny": "—Å–æ–Ω—è—á–Ω–∏–π", "mist": "—ñ–º–ª–∞/—Ç—É–º–∞–Ω", "thunderstorm": "–≥—Ä–æ–∑–∞",
  "wind": "–≤—ñ—Ç–µ—Ä", "hailstorm": "–≥—Ä–∞–¥", "fog": "—Ç—É–º–∞–Ω (–≥—É—Å—Ç—ñ—à–∏–π)", "ice": "–ª—ñ–¥",
  "freezing": "–¥—É–∂–µ —Ö–æ–ª–æ–¥–Ω–∏–π", "hot": "—Å–ø–µ–∫–æ—Ç–Ω–∏–π", "cool": "–ø—Ä–æ—Ö–æ–ª–æ–¥–Ω–∏–π", "mild": "–º‚Äô—è–∫–∏–π (–ø—Ä–æ –ø–æ–≥–æ–¥—É)",
  "sweltering": "–¥—É–∂–µ —Å–ø–µ–∫–æ—Ç–Ω–∏–π", "rain": "–¥–æ—â", "weather": "–ø–æ–≥–æ–¥–∞", "forecast": "–ø—Ä–æ–≥–Ω–æ–∑",

  // Disasters
  "hurricane": "—É—Ä–∞–≥–∞–Ω", "flood": "–ø–æ–≤—ñ–Ω—å", "mudslide": "—Å–µ–ª–µ–≤–∏–π –∑—Å—É–≤", "earthquake": "–∑–µ–º–ª–µ—Ç—Ä—É—Å",
  "tsunami": "—Ü—É–Ω–∞–º—ñ", "drought": "–ø–æ—Å—É—Ö–∞", "volcanic eruption": "–≤–∏–≤–µ—Ä–∂–µ–Ω–Ω—è –≤—É–ª–∫–∞–Ω–∞",
  "forest fire": "–ª—ñ—Å–æ–≤–∞ –ø–æ–∂–µ–∂–∞", "avalanche": "–ª–∞–≤–∏–Ω–∞", "storm": "—à—Ç–æ—Ä–º / –±—É—Ä—è",

  // Road / Place Nouns
  "road sign": "–¥–æ—Ä–æ–∂–Ω—ñ–π –∑–Ω–∞–∫", "pedestrian crossing": "–ø—ñ—à–æ—Ö—ñ–¥–Ω–∏–π –ø–µ—Ä–µ—Ö—ñ–¥", "billboard": "–±—ñ–ª–±–æ—Ä–¥",
  "shop sign": "–≤–∏–≤—ñ—Å–∫–∞ –º–∞–≥–∞–∑–∏–Ω—É", "traffic light": "—Å–≤—ñ—Ç–ª–æ—Ñ–æ—Ä", "bus stop": "–∞–≤—Ç–æ–±—É—Å–Ω–∞ –∑—É–ø–∏–Ω–∫–∞",
  "pavement": "—Ç—Ä–æ—Ç—É–∞—Ä", "street corner": "—Ä—ñ–≥ –≤—É–ª–∏—Ü—ñ", "lamp post": "–ª—ñ—Ö—Ç–∞—Ä–Ω–∏–π —Å—Ç–æ–≤–ø",
  "fire hydrant": "–ø–æ–∂–µ–∂–Ω–∏–π –≥—ñ–¥—Ä–∞–Ω—Ç", "highway": "—à–æ—Å–µ / —Ç—Ä–∞—Å–∞", "route": "–º–∞—Ä—à—Ä—É—Ç",
  "coast": "—É–∑–±–µ—Ä–µ–∂–∂—è", "lighthouse": "–º–∞—è–∫", "bridge": "–º—ñ—Å—Ç", "track": "—Å—Ç–µ–∂–∫–∞ / –∫–æ–ª—ñ—è",
  "valley": "–¥–æ–ª–∏–Ω–∞", "cliff": "—Å–∫–µ–ª—è / –∫—Ä—É—á–∞", "edge": "–∫—Ä–∞–π", "petrol station": "–ê–ó–° / –∑–∞–ø—Ä–∞–≤–∫–∞",
  "roadside": "—É–∑–±—ñ—á—á—è", "city": "–º—ñ—Å—Ç–æ", "outskirts": "–æ–∫–æ–ª–∏—Ü—ñ", "hill": "–ø–∞–≥–æ—Ä–±",
  "gate": "–≤–æ—Ä–æ—Ç–∞", "entrance": "–≤—Ö—ñ–¥", "car park": "–∞–≤—Ç–æ—Å—Ç–æ—è–Ω–∫–∞",

  // People & Roles
  "pedestrian": "–ø—ñ—à–æ—Ö—ñ–¥", "lady": "–ø–∞–Ω—ñ / –∂—ñ–Ω–∫–∞", "driver": "–≤–æ–¥—ñ–π", "engineer": "—ñ–Ω–∂–µ–Ω–µ—Ä",
  "guard": "–æ—Ö–æ—Ä–æ–Ω–µ—Ü—å", "police": "–ø–æ–ª—ñ—Ü—ñ—è", "firefighter": "–ø–æ–∂–µ–∂–Ω–∏–∫", "organiser": "–æ—Ä–≥–∞–Ω—ñ–∑–∞—Ç–æ—Ä",
  "staff": "–ø–µ—Ä—Å–æ–Ω–∞–ª", "electrician": "–µ–ª–µ–∫—Ç—Ä–∏–∫", "band": "–≥—É—Ä—Ç (–º—É–∑–∏—á–Ω–∏–π)", "crowd": "–Ω–∞—Ç–æ–≤–ø",

  // Objects & Things
  "van": "—Ñ—É—Ä–≥–æ–Ω", "ticket": "–∫–≤–∏—Ç–æ–∫", "snack": "–∑–∞–∫—É—Å–∫–∞ / –ø–µ—Ä–µ–∫—É—Å", "bag": "—Å—É–º–∫–∞ / –º—ñ—à–æ–∫",
  "engine": "–¥–≤–∏–≥—É–Ω", "GPS": "GPS / –Ω–∞–≤—ñ–≥–∞—Ç–æ—Ä", "playlist": "–ø–ª–µ–π–ª–∏—Å—Ç", "dog": "—Å–æ–±–∞–∫–∞",
  "leash": "–ø–æ–≤—ñ–¥–æ–∫", "tyre": "—à–∏–Ω–∞", "windscreen": "–ª–æ–±–æ–≤–µ —Å–∫–ª–æ", "milkshake": "–º—ñ–ª–∫—à–µ–π–∫",
  "chocolate": "—à–æ–∫–æ–ª–∞–¥", "marshmallow": "–∑–µ—Ñ—ñ—Ä / –º–∞—Ä—à–º–µ–ª–æ—É", "roof": "–¥–∞—Ö", "radio": "—Ä–∞–¥—ñ–æ",
  "hailstone": "–≥—Ä–∞–¥–∏–Ω–∞", "crack": "—Ç—Ä—ñ—â–∏–Ω–∞", "traffic": "–¥–æ—Ä–æ–∂–Ω—ñ–π —Ä—É—Ö", "light": "—Å–≤—ñ—Ç–ª–æ / –≤–æ–≥–æ–Ω—å",
  "shovel": "–ª–æ–ø–∞—Ç–∞", "mud": "–±–∞–≥–Ω—é–∫–∞ / –±—Ä—É–¥", "phone": "—Ç–µ–ª–µ—Ñ–æ–Ω", "signal": "—Å–∏–≥–Ω–∞–ª",
  "service": "–º–µ—Ä–µ–∂–∞ / –æ–±—Å–ª—É–≥–æ–≤—É–≤–∞–Ω–Ω—è", "tow truck": "–µ–≤–∞–∫—É–∞—Ç–æ—Ä", "thermometer": "—Ç–µ—Ä–º–æ–º–µ—Ç—Ä",
  "cable": "–∫–∞–±–µ–ª—å", "asphalt": "–∞—Å—Ñ–∞–ª—å—Ç", "suspension bridge": "–ø—ñ–¥–≤—ñ—Å–Ω–∏–π –º—ñ—Å—Ç", "water": "–≤–æ–¥–∞",
  "bolt": "–±–æ–ª—Ç", "smoke": "–¥–∏–º", "generator": "–≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä", "megaphone": "–º–µ–≥–∞—Ñ–æ–Ω",
  "transformer": "—Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ç–æ—Ä", "fuel line": "–ø–∞–ª–∏–≤–Ω–∏–π —à–ª–∞–Ω–≥", "duct tape": "—Å–∫–æ—Ç—á (–∫–ª–µ–π–∫–∞ —Å—Ç—Ä—ñ—á–∫–∞)",
  "VIP pass": "VIP-–ø–µ—Ä–µ–ø—É—Å—Ç–∫–∞", "poncho": "–ø–æ–Ω—á–æ", "cocoa": "–∫–∞–∫–∞–æ", "fireworks": "—Ñ–µ—î—Ä–≤–µ—Ä–∫",
  "confetti": "–∫–æ–Ω—Ñ–µ—Ç—ñ", "couch": "–¥–∏–≤–∞–Ω",

  // Actions & Events
  "festival": "—Ñ–µ—Å—Ç–∏–≤–∞–ª—å", "trip": "–ø–æ–¥–æ—Ä–æ–∂ / –ø–æ—ó–∑–¥–∫–∞", "music": "–º—É–∑–∏–∫–∞", "love": "–∫–æ—Ö–∞–Ω–Ω—è",
  "mood": "–Ω–∞—Å—Ç—Ä—ñ–π", "warm-up": "—Ä–æ–∑–º–∏–Ω–∫–∞ / —Ä–æ–∑—ñ–≥—Ä—ñ–≤", "view": "–∫—Ä–∞—î–≤–∏–¥", "karma": "–∫–∞—Ä–º–∞",
  "lesson": "—É—Ä–æ–∫", "crash": "–∞–≤–∞—Ä—ñ—è", "solo": "—Å–æ–ª–æ", "break": "–ø–µ—Ä–µ—Ä–≤–∞", "warning": "–ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è",
  "damage": "–ø–æ—à–∫–æ–¥–∂–µ–Ω–Ω—è", "detour": "–æ–±'—ó–∑–¥", "assistance": "–¥–æ–ø–æ–º–æ–≥–∞", "rumble": "–≥—É—Ä–∫—ñ—Ç",
  "earthquake": "–∑–µ–º–ª–µ—Ç—Ä—É—Å", "repair": "—Ä–µ–º–æ–Ω—Ç", "blackout": "–≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è —Å–≤—ñ—Ç–ª–∞",
  "power cut": "–≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –µ–ª–µ–∫—Ç—Ä–æ–µ–Ω–µ—Ä–≥—ñ—ó", "groan": "—Å—Ç–æ–≥—ñ–Ω", "encore": "–Ω–∞ –±—ñ—Å", "chorus": "–ø—Ä–∏—Å–ø—ñ–≤",

  // Phrasal Verbs
  "look after": "–ø—ñ–∫–ª—É–≤–∞—Ç–∏—Å—è –ø—Ä–æ", "wake up": "–ø—Ä–æ–∫–∏–¥–∞—Ç–∏—Å—è", "put off": "–≤—ñ–¥–∫–ª–∞–¥–∞—Ç–∏",
  "carry on": "–ø—Ä–æ–¥–æ–≤–∂—É–≤–∞—Ç–∏", "give up": "–∑–¥–∞–≤–∞—Ç–∏—Å—è/–ø—Ä–∏–ø–∏–Ω—è—Ç–∏", "come up with": "–≤–∏–≥–∞–¥–∞—Ç–∏/–∑–Ω–∞–π—Ç–∏ (—ñ–¥–µ—é)",
  "use up": "–≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –ø–æ–≤–Ω—ñ—Å—Ç—é", "close down": "–∑–∞–∫—Ä–∏—Ç–∏ (–ø—Ä–∏–ø–∏–Ω–∏—Ç–∏ —Ä–æ–±–æ—Ç—É)", "pack": "–ø–∞–∫—É–≤–∞—Ç–∏",
  "check": "–ø–µ—Ä–µ–≤—ñ—Ä—è—Ç–∏", "throw": "–∫–∏–¥–∞—Ç–∏", "jump": "—Å—Ç—Ä–∏–±–∞—Ç–∏", "head for": "–ø—Ä—è–º—É–≤–∞—Ç–∏ –¥–æ",
  "start": "–ø–æ—á–∏–Ω–∞—Ç–∏", "take off": "–∑–ª—ñ—Ç–∞—Ç–∏ / –ø–æ—á–∏–Ω–∞—Ç–∏—Å—è (–ø—Ä–æ –º—É–∑–∏–∫—É)", "sing along": "–ø—ñ–¥—Å–ø—ñ–≤—É–≤–∞—Ç–∏",
  "slow down": "—Å–ø–æ–≤—ñ–ª—å–Ω—é–≤–∞—Ç–∏(—Å—è)", "step onto": "—Å—Ç—É–ø–∞—Ç–∏ –Ω–∞", "brake": "–≥–∞–ª—å–º—É–≤–∞—Ç–∏",
  "wave": "–º–∞—Ö–∞—Ç–∏", "honk": "—Å–∏–≥–Ω–∞–ª–∏—Ç–∏ (–∞–≤—Ç–æ)", "spin": "–∫—Ä—É—Ç–∏—Ç–∏—Å—è", "slip": "–≤–∏—Å–ª–∏–∑–∞—Ç–∏",
  "stop": "–∑—É–ø–∏–Ω—è—Ç–∏(—Å—è)", "apologise": "–≤–∏–±–∞—á–∞—Ç–∏—Å—è", "roll over": "–ø–µ—Ä–µ–∫–æ—á—É–≤–∞—Ç–∏—Å—è / –Ω–∞–∫—Ä–∏–≤–∞—Ç–∏",
  "skid": "–∫–æ–≤–∑–∞—Ç–∏ (–Ω–∞ –¥–æ—Ä–æ–∑—ñ)", "control": "–∫–æ–Ω—Ç—Ä–æ–ª—é–≤–∞—Ç–∏", "gasp": "–∑–∞–¥–∏—Ö–∞—Ç–∏—Å—è / –∞—Ö–∞—Ç–∏",
  "yell": "–∫—Ä–∏—á–∞—Ç–∏ / –≤–µ—Ä–µ—â–∞—Ç–∏", "race": "–º—á–∞—Ç–∏ / –≥–Ω–∞—Ç–∏—Å—è", "promise": "–æ–±—ñ—Ü—è—Ç–∏",
  "growl": "–±—É—Ä—á–∞—Ç–∏ (–ø—Ä–æ –∂–∏–≤—ñ—Ç)", "pick up": "–ø—ñ–¥–±–∏—Ä–∞—Ç–∏", "rattle": "—Å—Ç—É–∫–æ—Ç—ñ—Ç–∏ / —Ç–æ—Ä–æ—Ö—Ç—ñ—Ç–∏",
  "gather": "–∑–±–∏—Ä–∞—Ç–∏—Å—è (–ø—Ä–æ —Ö–º–∞—Ä–∏)", "pull off": "–∑'—ó–∂–¥–∂–∞—Ç–∏ (–∑ –¥–æ—Ä–æ–≥–∏)", "block": "–±–ª–æ–∫—É–≤–∞—Ç–∏",
  "flash": "–±–ª–∏–º–∞—Ç–∏ / —Å–ø–∞–ª–∞—Ö—É–≤–∞—Ç–∏", "sink": "—Ç–æ–Ω—É—Ç–∏ / –≥—Ä—É–∑–Ω—É—Ç–∏", "dig out": "–≤–∏–∫–æ–ø—É–≤–∞—Ç–∏",
  "climb": "–ª–∞–∑–∏—Ç–∏ / –ø—ñ–¥–Ω—ñ–º–∞—Ç–∏—Å—è", "pick up (signal)": "–∑–ª–æ–≤–∏—Ç–∏ (—Å–∏–≥–Ω–∞–ª)", "slide down": "–∑'—ó–∂–¥–∂–∞—Ç–∏ –≤–Ω–∏–∑",
  "hug": "–æ–±—ñ–π–º–∞—Ç–∏", "shake": "—Ç—Ä—è—Å—Ç–∏(—Å—è)", "power up": "–≤–º–∏–∫–∞—Ç–∏ –∂–∏–≤–ª–µ–Ω–Ω—è / –∑–∞–ø—É—Å–∫–∞—Ç–∏",
  "sprint": "–±—ñ–≥—Ç–∏ —Å–ø—Ä–∏–Ω—Ç / –º—á–∞—Ç–∏", "fall": "–ø–∞–¥–∞—Ç–∏", "sway": "–≥–æ–π–¥–∞—Ç–∏—Å—è",
  "wave (cars)": "–º–∞—Ö–∞—Ç–∏ (–º–∞—à–∏–Ω–∞–º)", "creep": "–ø–æ–≤–∑—Ç–∏", "count": "—Ä–∞—Ö—É–≤–∞—Ç–∏",
  "make it": "–≤–ø–æ—Ä–∞—Ç–∏—Å—è / –¥—ñ—Å—Ç–∞—Ç–∏—Å—è", "cheer": "–≤—ñ—Ç–∞—Ç–∏ / –ø—ñ–¥–±–∞–¥—å–æ—Ä—é–≤–∞—Ç–∏", "glow": "—Å–≤—ñ—Ç–∏—Ç–∏—Å—è",
  "rise": "–ø—ñ–¥–Ω—ñ–º–∞—Ç–∏—Å—è", "volunteer": "–∑–≥–æ–ª–æ—Å–∏—Ç–∏—Å—è –¥–æ–±—Ä–æ–≤–æ–ª—å—Ü–µ–º", "hand out": "—Ä–æ–∑–¥–∞–≤–∞—Ç–∏",
  "carry": "–Ω–µ—Å—Ç–∏", "miss": "–ø—Ä–æ–ø—É—Å–∫–∞—Ç–∏ / —Å—É–º—É–≤–∞—Ç–∏", "build up": "–Ω–∞–∫–æ–ø–∏—á—É–≤–∞—Ç–∏—Å—è", "run": "–±—ñ–≥—Ç–∏",
  "check (tickets)": "–ø–µ—Ä–µ–≤—ñ—Ä—è—Ç–∏ (–∫–≤–∏—Ç–∫–∏)", "crawl": "–ø–æ–≤–∑—Ç–∏", "boom": "–≥—É—Ä–∫–æ—Ç—ñ—Ç–∏", "hit": "–≤–¥–∞—Ä—è—Ç–∏",
  "jump": "—Å—Ç—Ä–∏–±–∞—Ç–∏", "cut off": "–≤—ñ–¥–∫–ª—é—á–∞—Ç–∏ / –æ–±—Ä–∏–≤–∞—Ç–∏", "die": "–≥–∞—Å–Ω—É—Ç–∏ / –≤–º–∏—Ä–∞—Ç–∏",
  "sputter": "–ø–∏—Ö—Ç—ñ—Ç–∏ / —Ö—Ä–∏–ø—ñ—Ç–∏ (–ø—Ä–æ –¥–≤–∏–≥—É–Ω)", "figure out": "–∑'—è—Å—É–≤–∞—Ç–∏ / —Ä–æ–∑—ñ–±—Ä–∞—Ç–∏—Å—è",
  "tighten": "–∑–∞—Ç—è–≥—É–≤–∞—Ç–∏", "roar": "—Ä–µ–≤—ñ—Ç–∏", "blaze": "–ø–∞–ª–∞—Ç–∏", "save": "—Ä—è—Ç—É–≤–∞—Ç–∏ / –∑–±–µ—Ä—ñ–≥–∞—Ç–∏",
  "appear": "–∑'—è–≤–ª—è—Ç–∏—Å—è", "invite": "–∑–∞–ø—Ä–æ—à—É–≤–∞—Ç–∏",

  // Misc Grammar Words
  "bigger": "–±—ñ–ª—å—à–∏–π", "smaller": "–º–µ–Ω—à–∏–π", "hotter": "–≥–∞—Ä—è—á—ñ—à–∏–π", "colder": "—Ö–æ–ª–æ–¥–Ω—ñ—à–∏–π",
  "more dangerous": "–Ω–µ–±–µ–∑–ø–µ—á–Ω—ñ—à–∏–π", "safest": "–Ω–∞–π–±–µ–∑–ø–µ—á–Ω—ñ—à–∏–π", "longer": "–¥–æ–≤—à–∏–π",
  "more beautiful": "–∫—Ä–∞—Å–∏–≤—ñ—à–∏–π", "kinder": "–¥–æ–±—Ä—ñ—à–∏–π", "faster": "—à–≤–∏–¥—à–∏–π", "slower": "–ø–æ–≤—ñ–ª—å–Ω—ñ—à–∏–π",
  "darker": "—Ç–µ–º–Ω—ñ—à–∏–π", "steeper": "–∫—Ä—É—Ç—ñ—à–∏–π", "quieter": "—Ç–∏—Ö—ñ—à–∏–π", "brighter": "—è—Å–∫—Ä–∞–≤—ñ—à–∏–π",
  "warmer": "—Ç–µ–ø–ª—ñ—à–∏–π", "softer": "–º'—è–∫—à–∏–π", "lower": "–Ω–∏–∂—á–∏–π", "heavier": "–≤–∞–∂—á–∏–π",
  "closer": "–±–ª–∏–∂—á–∏–π", "wider": "—à–∏—Ä—à–∏–π", "greater": "–≤–µ–ª–∏—á–Ω—ñ—à–∏–π / –∫—Ä–∞—â–∏–π",
  "grey": "—Å—ñ—Ä–∏–π", "green": "–∑–µ–ª–µ–Ω–∏–π", "old": "—Å—Ç–∞—Ä–∏–π", "biggest": "–Ω–∞–π–±—ñ–ª—å—à–∏–π",
  "possible": "–º–æ–∂–ª–∏–≤–∏–π", "hazardous": "–Ω–µ–±–µ–∑–ø–µ—á–Ω–∏–π", "excited": "—Å—Ö–≤–∏–ª—å–æ–≤–∞–Ω–∏–π / –∑–±—É–¥–∂–µ–Ω–∏–π",
  "awesome": "–∫—Ä—É—Ç–∏–π / –¥–∏–≤–æ–≤–∏–∂–Ω–∏–π", "foggy": "—Ç—É–º–∞–Ω–Ω–∏–π", "sunny": "—Å–æ–Ω—è—á–Ω–∏–π", "scenic": "–º–∞–ª—å–æ–≤–Ω–∏—á–∏–π",
  "bright": "—è—Å–∫—Ä–∞–≤–∏–π", "gentle": "–Ω—ñ–∂–Ω–∏–π / –ª–∞–≥—ñ–¥–Ω–∏–π", "impatient": "–Ω–µ—Ç–µ—Ä–ø–ª—è—á–∏–π", "kind": "–¥–æ–±—Ä–∏–π / –ª—é–±'—è–∑–Ω–∏–π",
  "thick": "–≥—É—Å—Ç–∏–π / —Ç–æ–≤—Å—Ç–∏–π", "icy": "–∫—Ä–∏–∂–∞–Ω–∏–π / —Å–ª–∏–∑—å–∫–∏–π", "long": "–¥–æ–≤–≥–∏–π", "metal": "–º–µ—Ç–∞–ª–µ–≤–∏–π",
  "ghostly": "–ø—Ä–∏–º–∞—Ä–Ω–∏–π", "safe": "–±–µ–∑–ø–µ—á–Ω–∏–π", "lucky": "—â–∞—Å–ª–∏–≤–∏–π / –≤–¥–∞–ª–∏–π", "coolest": "–Ω–∞–π–∫—Ä—É—Ç—ñ—à–∏–π",
  "tiny": "–∫—Ä–∏—Ö—ñ—Ç–Ω–∏–π", "warm": "—Ç–µ–ø–ª–∏–π", "odd": "–¥–∏–≤–Ω–∏–π", "sweet": "—Å–æ–ª–æ–¥–∫–∏–π", "dark": "—Ç–µ–º–Ω–∏–π",
  "black": "—á–æ—Ä–Ω–∏–π", "marble-size": "—Ä–æ–∑–º—ñ—Ä–æ–º –∑ –º–∞—Ä–º—É—Ä–æ–≤—É –∫—É–ª—å–∫—É", "worst": "–Ω–∞–π–≥—ñ—Ä—à–∏–π",
  "stone": "–∫–∞–º'—è–Ω–∏–π", "fast": "—à–≤–∏–¥–∫–∏–π", "white": "–±—ñ–ª–∏–π", "spring": "–≤–µ—Å–Ω–∞", "winter": "–∑–∏–º–∞",
  "good": "–¥–æ–±—Ä–∏–π / –≥–∞—Ä–Ω–∏–π", "bad": "–ø–æ–≥–∞–Ω–∏–π", "small": "–º–∞–ª–µ–Ω—å–∫–∏–π", "closed": "–∑–∞—á–∏–Ω–µ–Ω–∏–π",
  "main": "–≥–æ–ª–æ–≤–Ω–∏–π", "flashing": "–º–∏–≥–æ—Ç–ª–∏–≤–∏–π", "narrow": "–≤—É–∑—å–∫–∏–π", "soft": "–º'—è–∫–∏–π",
  "stuck": "–∑–∞—Å—Ç—Ä—è–≥–ª–∏–π", "dry": "—Å—É—Ö–∏–π", "flat": "—Ä—ñ–≤–Ω–∏–π / –ø–ª–∞—Å–∫–∏–π", "fancy": "—à–∏–∫–∞—Ä–Ω–∏–π / –≤–∏—à—É–∫–∞–Ω–∏–π",
  "awake": "—Ç–æ–π, —â–æ –Ω–µ —Å–ø–∏—Ç—å", "farther": "–¥–∞–ª—ñ", "stiff": "–∑–∞–¥–µ—Ä–µ–≤'—è–Ω—ñ–ª–∏–π", "hopeful": "—Å–ø–æ–≤–Ω–µ–Ω–∏–π –Ω–∞–¥—ñ—ó",
  "spare": "–∑–∞–ø–∞—Å–Ω–∏–π", "empty": "–ø–æ—Ä–æ–∂–Ω—ñ–π", "official": "–æ—Ñ—ñ—Ü—ñ–π–Ω–∏–π", "unmarked": "–Ω–µ–ø–æ–∑–Ω–∞—á–µ–Ω–∏–π",
  "nearby": "–ø–æ–±–ª–∏–∑—É", "heavy": "–≤–∞–∂–∫–∏–π", "free": "–≤—ñ–ª—å–Ω–∏–π", "three hours": "—Ç—Ä–∏ –≥–æ–¥–∏–Ω–∏",
  "wooden": "–¥–µ—Ä–µ–≤'—è–Ω–∏–π", "steel": "—Å—Ç–∞–ª–µ–≤–∏–π", "two football fields": "–¥–≤–∞ —Ñ—É—Ç–±–æ–ª—å–Ω—ñ –ø–æ–ª—è",
  "damaged": "–ø–æ—à–∫–æ–¥–∂–µ–Ω–∏–π", "patiently": "—Ç–µ—Ä–ø–ª—è—á–µ", "twice": "–¥–≤—ñ—á—ñ", "halfway": "–Ω–∞ –ø—ñ–≤–¥–æ—Ä–æ–∑—ñ",
  "loud": "–≥—É—á–Ω–∏–π", "huge": "–≤–µ–ª–∏—á–µ–∑–Ω–∏–π", "neon": "–Ω–µ–æ–Ω–æ–≤–∏–π", "sleepy": "—Å–æ–Ω–Ω–∏–π",
  "steaming": "–ø–∞—Ä—É—é—á–µ", "backup": "—Ä–µ–∑–µ—Ä–≤–Ω–∏–π", "loose": "–æ—Å–ª–∞–±–ª–µ–Ω–∏–π", "five minutes": "–ø'—è—Ç—å —Ö–≤–∏–ª–∏–Ω",
  "last": "–æ—Å—Ç–∞–Ω–Ω—ñ–π", "off-key": "—Ñ–∞–ª—å—à–∏–≤–æ", "perfect": "—ñ–¥–µ–∞–ª—å–Ω–∏–π", "happy": "—â–∞—Å–ª–∏–≤–∏–π",

  // Basic Function Words
  "a": "–Ω–µ–æ–∑–Ω–∞—á–µ–Ω–∏–π –∞—Ä—Ç–∏–∫–ª—å", "the": "–æ–∑–Ω–∞—á–µ–Ω–∏–π –∞—Ä—Ç–∏–∫–ª—å", "is": "—î (–æ–¥–Ω.)", "are": "—î (–º–Ω.)",
  "was": "–±—É–≤/–±—É–ª–∞/–±—É–ª–æ", "were": "–±—É–ª–∏", "and": "—ñ / —Ç–∞", "or": "–∞–±–æ / —á–∏", "but": "–∞–ª–µ",
  "on": "–Ω–∞", "in": "–≤ / —É", "at": "–±—ñ–ª—è / –≤ / –Ω–∞", "of": "—Ä–æ–¥–æ–≤–∏–π –≤—ñ–¥–º—ñ–Ω–æ–∫", "for": "–¥–ª—è",
  "with": "–∑", "to": "–¥–æ / –≤", "from": "–∑ / –≤—ñ–¥", "ahead": "–ø–æ–ø–µ—Ä–µ–¥—É", "onto": "–Ω–∞ (—Ä—É—Ö)",
  "under": "–ø—ñ–¥", "than": "–Ω—ñ–∂", "like": "—è–∫ / —Å—Ö–æ–∂–∏–π –Ω–∞", "how": "—è–∫", "what": "—â–æ", "when": "–∫–æ–ª–∏",
  "where": "–¥–µ / –∫—É–¥–∏", "why": "—á–æ–º—É", "if": "—è–∫—â–æ", "maybe": "–º–æ–∂–ª–∏–≤–æ", "suddenly": "—Ä–∞–ø—Ç–æ–º",
  "anyway": "–≤—Å–µ –æ–¥–Ω–æ / —É –±—É–¥—å-—è–∫–æ–º—É –≤–∏–ø–∞–¥–∫—É", "luckily": "–Ω–∞ —â–∞—Å—Ç—è", "already": "–≤–∂–µ", "still": "–≤—Å–µ —â–µ",
  "just": "–ø—Ä–æ—Å—Ç–æ / —â–æ–π–Ω–æ", "ever": "–∫–æ–ª–∏-–Ω–µ–±—É–¥—å", "never": "–Ω—ñ–∫–æ–ª–∏", "ago": "—Ç–æ–º—É", "later": "–ø—ñ–∑–Ω—ñ—à–µ",
  "first": "—Å–ø–æ—á–∞—Ç–∫—É / –ø–µ—Ä—à–∏–π", "now": "–∑–∞—Ä–∞–∑", "then": "—Ç–æ–¥—ñ / –ø–æ—Ç—ñ–º", "only": "—Ç—ñ–ª—å–∫–∏ / –ª–∏—à–µ",
  "almost": "–º–∞–π–∂–µ", "even": "–Ω–∞–≤—ñ—Ç—å", "also": "—Ç–∞–∫–æ–∂", "too": "—Ç–µ–∂ / –∑–∞–Ω–∞–¥—Ç–æ", "very": "–¥—É–∂–µ",
  "really": "—Å–ø—Ä–∞–≤–¥—ñ / –¥—ñ–π—Å–Ω–æ", "together": "—Ä–∞–∑–æ–º", "around": "–Ω–∞–≤–∫–æ–ª–æ / –±–ª–∏–∑—å–∫–æ", "behind": "–ø–æ–∑–∞–¥—É",
  "across": "—á–µ—Ä–µ–∑ / –ø–æ–ø–µ—Ä–µ–∫", "through": "–∫—Ä—ñ–∑—å / —á–µ—Ä–µ–∑", "towards": "—É –Ω–∞–ø—Ä—è–º–∫—É –¥–æ", "above": "–Ω–∞–¥",
  "near": "–±—ñ–ª—è", "next": "–Ω–∞—Å—Ç—É–ø–Ω–∏–π", "finally": "–Ω–∞—Ä–µ—à—Ç—ñ", "politely": "–≤–≤—ñ—á–ª–∏–≤–æ",
  "straight": "–ø—Ä—è–º–æ", "quickly": "—à–≤–∏–¥–∫–æ", "slowly": "–ø–æ–≤—ñ–ª—å–Ω–æ", "loudly": "–≥–æ–ª–æ—Å–Ω–æ",
  "gently": "–Ω—ñ–∂–Ω–æ / –æ–±–µ—Ä–µ–∂–Ω–æ", "yes": "—Ç–∞–∫", "no": "–Ω—ñ", "‚úì": "‚úì (—Ç–∞–∫ / –≤–∏–∫–æ–Ω–∞–Ω–æ)"
};




// --- DOM Elements ---
const sceneTextEl = document.getElementById('scene-text');
const choicesContainerEl = document.getElementById('choices-container');
const outcomeDisplayEl = document.getElementById('outcome-display');
const voiceButton = document.getElementById('voice-button');
const voiceStatusEl = document.getElementById('voice-status');
const startChallengeBtn = document.getElementById('start-challenge-btn'); // Renamed
const vocabListContainer = document.getElementById('vocab-list-container');

// --- Game State ---
let currentSceneId = 'start';
let currentChoices = []; // Holds the {text, nextScene} objects for the current scene
let isMemoryCheckPhase = false; // Is the player currently supposed to recall the English text?
let isChoiceSpeakingPhase = false; // Is the player supposed to speak their choice?
let originalEnglishTextForMemoryCheck = ""; // Stores formatted EN text for recall comparison/display
let formattedUkrainianTextForMemoryCheck = "";// Stores formatted UA text to show during recall
let memoryCheckPassed = false; // Did the player succeed in the last memory check?
let ttsUnlocked = false; // Has the user interaction unlocked text-to-speech?
let micPermissionGranted = null; // null: unknown, true: granted, false: denied
let isListening = false; // Is the speech recognition actively listening?

const MEMORY_SIMILARITY_THRESHOLD = 0.50; // Required similarity (0-1) for memory check

// --- Text-to-Speech (TTS) Setup ---
const synth = window.speechSynthesis;
let currentUtterance = null;
let selectedVoice = null; // Holds the chosen English voice object
let voicesLoaded = false;

if (synth && typeof synth.onvoiceschanged !== 'undefined') {
    synth.onvoiceschanged = () => {
        voicesLoaded = true;
        console.log("[Init] System voices loaded/changed:", synth.getVoices().length);
         // Re-select best voice if they change after initial load
         if (ttsUnlocked) { // Only if game has started/audio enabled
            selectedVoice = getBestVoice();
            console.log("[TTS] Voices changed, re-selected voice:", selectedVoice ? selectedVoice.name : "default");
         }
    };
}
if (synth && synth.getVoices().length === 0) {
    synth.getVoices(); // Try to preload
}


// --- Speech Recognition Setup ---
const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition || null;
let recognition = null; // Holds the SpeechRecognition instance


// --- Helper Functions ---

// ----------  SENTENCE   WRAPPING  +  TRANSLATION  TOOLTIP  ----------------
/**
 * Wraps every English sentence in a span that keeps both EN + UA versions.
 * If a UA version is missing it will be filled on‚Äëdemand via Google‚ÄëTranslate.
 */

 /* =========================================================================
   ‚ù∂  Make ALL English text nodes translatable
   ------------------------------------------------------------------------ */
 function makeTextNodesTranslatable(rootEl){
    if(!rootEl) return;

    const walker = document.createTreeWalker(
        rootEl,
        NodeFilter.SHOW_TEXT,
        {
            acceptNode(node){
                // skip empty / whitespace
                if(!node.nodeValue || /^\s*$/.test(node.nodeValue)) return NodeFilter.FILTER_REJECT;
                // only English letters?
                if(!/[A-Za-z]/.test(node.nodeValue)) return NodeFilter.FILTER_REJECT;
                // already wrapped?
                if(node.parentNode && node.parentNode.classList &&
                   node.parentNode.classList.contains('translatable-sentence')){
                    return NodeFilter.FILTER_REJECT;
                }
                return NodeFilter.FILTER_ACCEPT;
            }
        },
        false
    );

    const toWrap=[];
    while(walker.nextNode()) toWrap.push(walker.currentNode);

    toWrap.forEach(node=>{
        const span = document.createElement('span');
        span.className = 'translatable-sentence';
        span.dataset.en = node.nodeValue.trim();
        span.textContent = node.nodeValue;
        node.parentNode.replaceChild(span,node);
    });
}

/* =========================================================================
   WRAP COMPLETE ENGLISH SENTENCES  (works even with <span> keywords inside)
   ------------------------------------------------------------------------ */
   function wrapSentencesWithTranslation(rawEn, uaText){
    // ‚ë†  split the *plain* English into sentences
    const plainSentences = rawEn
        .match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [];

    // ‚ë°  insert unique tokens ‚Äì later we can find them after keyword‚Äëhighlighting
    let tokenised = rawEn;
    const tokens = [];                 // [{tok:'%%TX0%%', en:'...', ua:'...'}]
    plainSentences.forEach((s,i)=>{
        const tok = `%%TX${i}%%`;
        tokens.push({tok, en:s.trim(), ua:(uaText.match(/[^.!?]+[.!?]+|[^.!?]+$/g)||[])[i]||''});
        tokenised = tokenised.replace(s, tok);   // first occurrence only
    });

    // ‚ë¢  run your existing highlight code *after* tokenisation
    tokenised = formatText(tokenised);

    // ‚ë£  swap tokens for <span class="translatable-sentence"> ‚Ä¶ </span>
    tokens.forEach(({tok,en,ua})=>{
        // find the highlighted version of this sentence (may contain keyword spans now)
        const regexTok = new RegExp(tok.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'));
        tokenised = tokenised.replace(
            regexTok,
            `<span class="translatable-sentence" data-en="${en.replace(/"/g,'&quot;')}" data-ua="${ua.replace(/"/g,'&quot;')}">${formatText(en)}</span>`
        );
    });

    return tokenised;
}


/** Removes HTML tags */
function stripHtml(htmlString) {
    if (!htmlString) return "";
    const tmp = document.createElement("DIV");
    tmp.innerHTML = htmlString;
    return tmp.textContent || tmp.innerText || "";
}

/** Formats text: highlights vocab & location */
function formatText(text) {
    if (!text) return "";
    let formattedText = String(text);
    formattedText = formattedText.replace(/\[Location: (.*?)\]/g, '<span class="location-text">Location: $1</span>');
    const sortedVocab = [...vocabulary].sort((a, b) => b.length - a.length);
    sortedVocab.forEach(word => {
        try {
            const escapedWord = word.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            // Regex to match whole words, avoiding matches inside HTML tags or already highlighted spans
            const regex = new RegExp(`(?<!<[^>]*?)(?<!<(?:span|div|p)\\s[^>]*>)(?<!<span class="[^"]*">)(\\b${escapedWord}\\b)(?![^<]*?>)(?![^<]*<\\/(?:span|div|p)>)`, 'gi');
             formattedText = formattedText.replace(regex, (match) => {
                 // Basic check to avoid re-wrapping common tags if regex fails
                 if (match.toLowerCase().includes('<span class') || match.toLowerCase().includes('<div') ) return match;
                 return `<span class="keyword-highlight">${match}</span>`;
            });
        } catch (e) { console.error(`[FormatText] Regex error for word "${word}":`, e); }
    });
    return formattedText;
}

/** Updates the vocabulary list based on current scene text */
function updateVocabList(currentText) {
    if (!vocabListContainer) return;
    vocabListContainer.innerHTML = '';
    const plainTextLower = currentText.toLowerCase();
    const foundWords = new Set();

    vocabulary.forEach(word => {
        try {
            const escapedWord = word.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            const regex = new RegExp(`\\b${escapedWord}\\b`, 'i');
            if (regex.test(plainTextLower)) {
                foundWords.add(word);
            }
        } catch (e) { console.error(`[VocabList] Regex error checking word "${word}":`, e); }
    });

    if (foundWords.size > 0) {
        const ul = document.createElement('ul');
        const sortedFoundWords = Array.from(foundWords).sort();
        sortedFoundWords.forEach(enWord => {
            const uaWord = vocabTranslations[enWord] || '[Translation N/A]';
            const li = document.createElement('li');
            li.innerHTML = `<span class="ua-term">${uaWord}</span> - ${enWord}`;
            ul.appendChild(li);
        });
        vocabListContainer.appendChild(ul);
        // Visibility controlled by game state functions now
    } else {
        // Ensure it's hidden if no words found
         vocabListContainer.classList.add('hidden');
    }
}

/** Calculates Levenshtein distance */
function levenshteinDistance(a = "", b = "") {
    // (Implementation remains the same as original)
      const strA = String(a).toLowerCase();
      const strB = String(b).toLowerCase();
      if (strA.length === 0) return strB.length;
      if (strB.length === 0) return strA.length;
      const matrix = Array(strB.length + 1).fill(null).map(() => Array(strA.length + 1).fill(null));
      for (let i = 0; i <= strA.length; i++) matrix[0][i] = i;
      for (let j = 0; j <= strB.length; j++) matrix[j][0] = j;
      for (let j = 1; j <= strB.length; j++) {
          for (let i = 1; i <= strA.length; i++) {
              const cost = strA[i - 1] === strB[j - 1] ? 0 : 1;
              matrix[j][i] = Math.min(
                  matrix[j][i - 1] + 1,     // Deletion
                  matrix[j - 1][i] + 1,     // Insertion
                  matrix[j - 1][i - 1] + cost // Substitution
              );
          }
      }
      return matrix[strB.length][strA.length];
}

/** Calculates similarity score (0-1) */
function calculateSimilarity(text1, text2) {
    const distance = levenshteinDistance(text1, text2);
    const len1 = String(text1).length;
    const len2 = String(text2).length;
    const maxLength = Math.max(len1, len2);
    if (maxLength === 0) return 1;
    const similarity = 1 - (distance / maxLength);
    return Math.max(0, similarity);
}

/** Displays English text after memory check, highlighting matched words */
function displayAndHighlightMemoryCheck(originalHTML, spokenTranscript) {
     const plainOriginal = stripHtml(originalHTML).toLowerCase();
     const originalWords = plainOriginal.split(/\s+/).filter(w => w.length > 0);
     const spokenWords = spokenTranscript ? spokenTranscript.toLowerCase().split(/\s+/).filter(w => w.length > 0) : [];
     const spokenWordSet = new Set(spokenWords);
     let highlightedHTML = originalHTML; // Start with the formatted HTML
     const matchedOriginalWords = new Set();

     originalWords.forEach(word => {
         const cleanWord = word.replace(/[.,!?;:]/g, '');
         if (cleanWord && spokenWordSet.has(cleanWord)) {
             matchedOriginalWords.add(cleanWord);
         }
     });
      console.log("[Highlight] Matched words found:", Array.from(matchedOriginalWords));

     // Apply memory-match class to matched words in the original *formatted* HTML
     matchedOriginalWords.forEach(word => {
         if (!word) return;
         try {
             const escapedWord = word.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
             // More specific regex to avoid matching inside tags or already wrapped spans
             const regex = new RegExp(`(?<=>[^<]*)(\\b${escapedWord}\\b)(?=[^<]*<)|(?<!=["'\\/])(\\b${escapedWord}\\b)(?!["'\\/])`, 'gi');

             highlightedHTML = highlightedHTML.replace(regex, (match, group1, group2) => {
                 const actualMatch = group1 || group2; // Get the matched word
                 // Check if the match is already inside a span (basic check)
                 // This is tricky - aiming to not double-wrap
                  const surroundingChars = highlightedHTML.substring(
                      Math.max(0, highlightedHTML.indexOf(actualMatch) - 10),
                      highlightedHTML.indexOf(actualMatch) + actualMatch.length + 10
                 );
                 if (surroundingChars.includes('<span class="memory-match">') || surroundingChars.includes('<span class="keyword-highlight">')) {
                     return actualMatch; // Avoid re-wrapping if it looks like it's already wrapped
                 }
                 return `<span class="memory-match">${actualMatch}</span>`;
             });
         } catch (e) { console.error(`[Highlight] Regex error for word "${word}":`, e); }
     });

     sceneTextEl.innerHTML = highlightedHTML; // Display the result with highlights

     sceneTextEl.classList.remove('memory-recall-active');
}


// --- UI Element State Management ---

/** Updates voice button text and style based on game state */
function updateVoiceButtonUI() {
    if (!voiceButton) return;
    voiceButton.classList.remove('listening', 'bg-accent', 'hover:bg-accent-dark', 'bg-info');

    if (isListening) {
        voiceButton.classList.add('listening', 'bg-info');
        if (isMemoryCheckPhase) {
            voiceButton.textContent = 'Listening for Recall... üëÇ';
        } else if (isChoiceSpeakingPhase) {
            voiceButton.textContent = 'Listening for Choice... üëÇ';
        } else {
             voiceButton.textContent = 'Listening... üëÇ'; // Generic fallback
        }
    } else {
         // Default button state
        voiceButton.classList.add('bg-accent', 'hover:bg-accent-dark');
        if (isMemoryCheckPhase) {
            voiceButton.textContent = 'Speak English Text üé§';
            voiceStatusEl.textContent = "Click button above to speak the English text you heard.";
            voiceStatusEl.className = 'text-highlight';
        } else if (isChoiceSpeakingPhase) {
            voiceButton.textContent = 'Speak Choice üé§';
            voiceStatusEl.textContent = "Click button above to speak your choice.";
             voiceStatusEl.className = 'text-info';
        } else {
             // Button shouldn't normally be active here unless end/error
             voiceButton.textContent = 'Speak Action üé§';
        }
    }

    // Handle disabled states last
     if (!SpeechRecognitionAPI) {
        voiceButton.disabled = true;
        voiceButton.textContent = 'Voice Not Supported';
    } else if (micPermissionGranted === false) {
        voiceButton.disabled = true;
        voiceButton.textContent = 'Mic Disabled';
    } else {
         // Enable button if mic is ok AND it's relevant phase, disable otherwise
         voiceButton.disabled = !(isMemoryCheckPhase || isChoiceSpeakingPhase);
    }
}

/** Hides or shows the choices container */
 function setChoicesVisibility(visible) {
     if (visible) {
         choicesContainerEl.classList.remove('hidden');
         // Note: Buttons themselves remain non-interactive per CSS/JS logic change
     } else {
         choicesContainerEl.classList.add('hidden');
     }
 }

/** Hides or shows the vocabulary list */
function setVocabListVisibility(visible) {
     if (visible) {
         vocabListContainer.classList.remove('hidden');
     } else {
         vocabListContainer.classList.add('hidden');
     }
}

// --- Text-to-Speech (TTS) Functionality ---

/** Finds the best available English voice */
function getBestVoice() {
    const voices = synth.getVoices();
    // Prefer enhanced/premium, then specific known good ones, then any US/GB, then any English
    return voices.find(v => v.lang.startsWith('en') && (v.name.toLowerCase().includes('enhanced') || v.name.toLowerCase().includes('premium'))) ||
           voices.find(v => v.lang.startsWith('en') && (v.name.toLowerCase().includes('daniel') || v.name.toLowerCase().includes('samantha'))) ||
           voices.find(v => v.lang.toLowerCase() === 'en-gb') ||
           voices.find(v => v.lang.toLowerCase() === 'en-us') ||
           voices.find(v => v.lang.startsWith('en')) ||
           null;
}

/** Speaks text using selected voice */
function speakText(textToSpeak, lang = 'en-GB', onEndCallback = null) {
    const availableVoices = synth.getVoices();
    // console.log(`[TTS Debug] speakText called. Voices: ${availableVoices.length}. Loaded: ${voicesLoaded}. Unlocked: ${ttsUnlocked}`);

    if (!synth || !ttsUnlocked || !textToSpeak) {
        console.warn(`[TTS] Skipping speech (Synth: ${!!synth}, Unlocked: ${ttsUnlocked}, Text: ${!!textToSpeak})`);
        if (onEndCallback) setTimeout(onEndCallback, 0); // Ensure callback runs even if skipped
        return;
    }

    if (synth.speaking) {
        console.log("[TTS] Cancelling previous utterance sequence.");
        synth.cancel(); // Cancel any ongoing/queued speech first
    }

    const plainText = stripHtml(textToSpeak).trim();
    if (!plainText) {
        console.log("[TTS] No text to speak after trimming.");
        if (onEndCallback) setTimeout(onEndCallback, 0); // Ensure callback runs even if empty
        return;
    }

    // --- Sentence Splitting ---
    // Match sequences ending in sentence punctuation (. ! ?) OR the final part of the string.
    const sentences = plainText.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [];
    const validSentences = sentences.map(s => s.trim()).filter(s => s.length > 0);

    if (validSentences.length === 0) {
        console.log("[TTS] No valid sentences found after splitting.");
        if (onEndCallback) setTimeout(onEndCallback, 0);
        return;
    }
    // console.log(`[TTS] Split into ${validSentences.length} sentences.`);

    let callbackCalled = false; // Flag to prevent multiple calls to onEndCallback
    let fallbackTimer = null;   // Handle for the safety timeout

    // --- Completion Handler ---
    // Central function to handle cleanup and calling the final callback
    const handleCompletion = (error = null) => {
        if (callbackCalled) return; // Already handled
        callbackCalled = true;
        clearTimeout(fallbackTimer); // Clear timer
        sceneTextEl.classList.remove('speaking'); // UI cleanup

        if (error) {
            console.error('[TTS] Utterance error during sequence:', error);
            // Cancel any further utterances that might be queued
            synth.cancel();
        } else {
            // console.log('[TTS] Sentence sequence successfully finished.');
        }

        // Call the original callback provided to speakText
        if (onEndCallback) {
            try {
                onEndCallback();
            } catch (e) {
                console.error("[TTS] Error executing onEndCallback:", e);
            }
        }
    };

    // --- Create Utterances ---
    const utterances = validSentences.map((sentence, index) => {
        const utterance = new SpeechSynthesisUtterance(sentence);
        utterance.lang = selectedVoice ? selectedVoice.lang : lang;
        utterance.voice = selectedVoice;

        // General error handler for any utterance in the sequence
        utterance.onerror = (event) => {
            handleCompletion(`Error on sentence ${index + 1}: ${event.error}`);
        };

        // The *last* utterance's onend triggers the final successful completion
        if (index === validSentences.length - 1) {
            utterance.onend = () => {
                handleCompletion(); // Success path
            };
        } else {
            // Optional: Log when intermediate sentences finish
            utterance.onend = () => {
                // console.log(`[TTS] Sentence ${index + 1} of ${validSentences.length} ended.`);
            };
        }

        // The *first* utterance's onstart visually indicates speaking has begun
        if (index === 0) {
            utterance.onstart = () => {
                // console.log('[TTS] Sentence sequence started.');
                sceneTextEl.classList.add('speaking');
            };
        }

        return utterance;
    });

    // --- Safety Timeout (for the whole sequence) ---
    const totalChars = plainText.length;
    // Estimate: time per char + overhead per sentence + buffer
    const estimatedDurationMs = (totalChars / 12) * 1000 + (validSentences.length * 1200) + 6000; // Adjusted estimation
    // Ensure a minimum reasonable time per sentence
    const minDuration = Math.max(5000 * validSentences.length, 10000); // e.g. 5s/sentence, min 10s total
    const maxDurationMs = Math.max(estimatedDurationMs, minDuration);
    // console.log(`[TTS] Setting fallback timer for sequence: ${maxDurationMs}ms`);

    fallbackTimer = setTimeout(() => {
        if (!callbackCalled) {
            console.warn(`[TTS] Fallback timer triggered for sequence after ${maxDurationMs}ms. Speech may be stuck. Forcing callback.`);
            handleCompletion("Fallback Timeout"); // Call completion handler with error indication
        }
    }, maxDurationMs);
    // --- End Safety Timeout ---

    // --- Queue all utterances for speaking ---
    // console.log(`[TTS] Queuing ${utterances.length} utterances.`);
    try {
         utterances.forEach(utt => synth.speak(utt));
    } catch (e) {
         console.error("[TTS] Error calling synth.speak() while queuing:", e);
         // If speaking fails immediately, trigger completion
         handleCompletion("Speak Error during queuing");
    }
}

// --- Speech Recognition Functionality ---

/** Initializes Speech Recognition */
function initializeSpeechRecognition() {
     if (!SpeechRecognitionAPI) {
         console.warn('[SpeechRec] API not supported.');
         updateVoiceButtonUI(); // Ensure button shows unsupported state
         return;
     }
     if (recognition) {
         console.log("[SpeechRec] Already initialized.");
         return; // Avoid re-initializing
     }

    try {
        recognition = new SpeechRecognitionAPI();
        recognition.continuous = true; // Process single utterance
        recognition.lang = 'en-US';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;

        recognition.onstart = () => {
            isListening = true;
            updateVoiceButtonUI();
            console.log('[SpeechRec] Event: onstart');
        };

        recognition.onresult = (event) => {
            console.log('[SpeechRec] Event: onresult');
            let transcript = "";
            if (event.results && event.results[0] && event.results[0][0]) {
                transcript = event.results[0][0].transcript.trim();
            } else {
                 console.warn("[SpeechRec] onresult: Received empty/malformed results.");
            }
            console.log(`[SpeechRec] Recognized: "${transcript}"`);

             // Stop listening once we have a result
             if (recognition && isListening) {
                 try { recognition.stop(); } catch(e) { console.warn("Error stopping recognition after result:", e); }
             }

            if (isMemoryCheckPhase) {
                processMemoryCheckResult(transcript);
            } else if (isChoiceSpeakingPhase) {
                processChoiceSpeechResult(transcript);
            } else {
                 console.warn("[SpeechRec] Received result in unexpected phase.");
            }
        };

        recognition.onerror = (event) => {
            console.error('[SpeechRec] Event: onerror - Error:', event.error, 'Message:', event.message);
            let errorMessage = 'Speech recognition error';
            switch (event.error) {
                case 'no-speech': errorMessage = 'No speech detected.'; break;
                case 'audio-capture': errorMessage = 'Mic error. Check connection/permissions.'; break;
                case 'not-allowed': errorMessage = 'Mic access denied.'; micPermissionGranted = false; break; // Update state
                case 'network': errorMessage = 'Network error.'; break;
                case 'aborted': errorMessage = 'Speech input stopped.'; break; // Less alarming
                 case 'service-not-allowed': errorMessage = 'Speech service denied.'; break;
                default: errorMessage = `Error: ${event.error || 'Unknown'}`;
            }
            if (event.error !== 'aborted') { // Don't show status for manual aborts if possible
                voiceStatusEl.textContent = `Error: ${errorMessage}`;
                voiceStatusEl.className = 'text-danger';
            }
            // Let onend handle final UI state reset
        };

        recognition.onend = () => {
            console.log('[SpeechRec] Event: onend');
            isListening = false;
            updateVoiceButtonUI(); // Reset button state after listening stops
        };

         console.log("[SpeechRec] Initialization complete.");

    } catch (e) {
        console.error("[SpeechRec] Error creating SpeechRecognition object:", e);
        recognition = null; // Ensure it's null if creation failed
        updateVoiceButtonUI(); // Update button to show error/unsupported
    }
}
// --- End of Chunk 1 ---
// --- Start of Chunk 2 ---
// (Continuing script from Chunk 1)

/** Processes speech result during memory check */
function processMemoryCheckResult(transcript) {
    console.log('[MemoryCheck] Processing transcript:', `"${transcript}"`);
    const feedbackArea = document.getElementById('feedback-percentage-area'); // Get the new feedback element

    // Clear any previous feedback first
    if (feedbackArea) {
        feedbackArea.textContent = '';
        // Reset classes, removing color helpers like text-success or text-highlight
        feedbackArea.className = 'text-center font-semibold mt-2 min-h-[1.2em]';
    }

    if (!originalEnglishTextForMemoryCheck) {
        console.error("[MemoryCheck] ERROR: Original English text missing!");
        voiceStatusEl.textContent = "Error: Cannot perform memory check."; // Use main status for errors
        voiceStatusEl.className = 'text-danger';
        if (feedbackArea) feedbackArea.textContent = 'Error checking recall.'; // Also show error in feedback
        isMemoryCheckPhase = false;
        memoryCheckPassed = false;
        updateVoiceButtonUI();
        return;
    }

    const plainOriginal = stripHtml(originalEnglishTextForMemoryCheck).toLowerCase();
    const plainTranscript = transcript ? transcript.toLowerCase() : "";
    const similarity = calculateSimilarity(plainOriginal, plainTranscript);
    const similarityPercent = (similarity * 100).toFixed(0);
    const feedbackDisplayDuration = 3000; // Keep feedback visible for 3 seconds

    console.log(`[MemoryCheck] Similarity: ${similarity.toFixed(3)} (${similarityPercent}%)`);

    if (similarity >= MEMORY_SIMILARITY_THRESHOLD) {
        console.log("[MemoryCheck] PASSED.");

        // --- Display percentage in the dedicated feedback area ---
        if (feedbackArea) {
            feedbackArea.textContent = `Recall Success: ${similarityPercent}%`;
            feedbackArea.classList.add('text-success'); // Apply success color
        }

        // --- Set NEXT INSTRUCTION in the main voiceStatusEl ---
        voiceStatusEl.textContent = `Choices below. Click button to speak choice.`;
        voiceStatusEl.className = 'text-info'; // Use neutral color for instruction

        // --- Perform immediate state updates and UI changes for pass ---
        memoryCheckPassed = true;
        isMemoryCheckPhase = false;
        isChoiceSpeakingPhase = true;
        displayAndHighlightMemoryCheck(originalEnglishTextForMemoryCheck, plainTranscript);
        setVocabListVisibility(true);
        setChoicesVisibility(true);
        updateVoiceButtonUI(); // Update button for choice speaking phase

        // --- Schedule clearing of the dedicated feedback area ---
        if (feedbackArea) {
            setTimeout(() => {
                feedbackArea.textContent = ''; // Clear the text
                feedbackArea.className = 'text-center font-semibold mt-2 min-h-[1.2em]'; // Reset class
            }, feedbackDisplayDuration);
        }

    } else {
        console.log("[MemoryCheck] FAILED.");

        // --- Display percentage in the dedicated feedback area ---
        if (feedbackArea) {
            feedbackArea.textContent = `Recall Failed: ${similarityPercent}%`;
            feedbackArea.classList.add('text-highlight'); // Apply retry/fail color
        }

        // --- Set NEXT INSTRUCTION in the main voiceStatusEl ---
        voiceStatusEl.textContent = `Click button to try recall again.`;
        voiceStatusEl.className = 'text-highlight'; // Match feedback color for retry instruction

        // --- Perform immediate state updates and UI changes for fail ---
        memoryCheckPassed = false;
        isMemoryCheckPhase = true; // Stay in memory phase
        isChoiceSpeakingPhase = false;
        sceneTextEl.innerHTML = originalEnglishTextForMemoryCheck; // Show original text again
        sceneTextEl.classList.remove('memory-recall-active');
        setVocabListVisibility(true);
        setChoicesVisibility(false); // Keep choices hidden
        updateVoiceButtonUI(); // Keep button active for memory check retry

        // --- Schedule clearing of the dedicated feedback area ---
        if (feedbackArea) {
            setTimeout(() => {
                feedbackArea.textContent = ''; // Clear the text
                feedbackArea.className = 'text-center font-semibold mt-2 min-h-[1.2em]'; // Reset class
            }, feedbackDisplayDuration);
        }
    }
}

/** Processes speech result during choice selection phase */
function processChoiceSpeechResult(transcript) {
     console.log("[ChoiceSpeak] Processing transcript:", `"${transcript}"`);
     if (!isChoiceSpeakingPhase) {
         console.warn("[ChoiceSpeak] Received result outside of choice speaking phase. Ignoring.");
         return;
     }
     if (!currentChoices || currentChoices.length === 0) {
         console.warn("[ChoiceSpeak] No current choices available to match against.");
         voiceStatusEl.textContent = "No choices available.";
         voiceStatusEl.className = 'text-highlight';
         return;
     }

    const bestMatch = findBestMatchChoice(transcript, currentChoices);

    if (bestMatch) {
        console.log(`[ChoiceSpeak] Best match found: "${stripHtml(bestMatch.choiceData.text)}"`);
        voiceStatusEl.textContent = `Choosing: "${stripHtml(bestMatch.choiceData.text)}"...`;
        voiceStatusEl.className = 'text-info';

        // Transition out of choice speaking phase *before* handling choice
        isChoiceSpeakingPhase = false;
        updateVoiceButtonUI(); // Disable button during transition

        setTimeout(() => {
             console.log("[ChoiceSpeak] Executing handleChoice after delay.");
            handleChoice(bestMatch.choiceData);
        }, 800); // Short delay for user feedback

    } else {
        console.log("[ChoiceSpeak] No suitable choice match found.");
        voiceStatusEl.textContent = `No clear match for "${transcript}". Click button to try speaking again.`;
        voiceStatusEl.className = 'text-highlight';
         // Remain in choice speaking phase for retry
         isChoiceSpeakingPhase = true;
         updateVoiceButtonUI(); // Keep button enabled for retry
    }
}

/** Helper to find the best choice match for spoken text */
function findBestMatchChoice(transcript, choices) {
    if (!transcript || !choices || choices.length === 0) return null;
    let bestMatch = null;
    let highestSimilarity = -1;
    const normalizedTranscript = transcript.toLowerCase().trim().replace(/[.,!?;:]/g, '');

    choices.forEach((choice, index) => {
        const plainChoiceText = stripHtml(choice.text).toLowerCase().trim().replace(/[.,!?;:]/g, '');
        if (!plainChoiceText) return;

         // Calculate similarity - potentially use a slightly lower threshold for choices
         const similarity = calculateSimilarity(normalizedTranscript, plainChoiceText);
         const similarityThreshold = 0.40; // May need adjustment

        if (similarity >= similarityThreshold && similarity > highestSimilarity) {
            highestSimilarity = similarity;
            bestMatch = { choiceData: choice, index: index, similarity: similarity };
        }
         // --- Add Keyword Matching Boost ---
         // Simple check if any important word from the choice is in the transcript
         const choiceWords = plainChoiceText.split(/\s+/).filter(w => w.length > 3); // Ignore short words
         const transcriptWords = new Set(normalizedTranscript.split(/\s+/));
         let keywordMatch = false;
         for (const cw of choiceWords) {
             if (transcriptWords.has(cw)) {
                 keywordMatch = true;
                 break;
             }
         }
         // If keywords match and similarity is decent (but maybe not highest), consider it a good candidate
         if (keywordMatch && similarity > 0.30 && similarity > highestSimilarity * 0.8) { // Adjust boost logic as needed
             // console.log(`[ChoiceSpeak] Keyword boost for: "${plainChoiceText}" (Sim: ${similarity.toFixed(2)})`);
             highestSimilarity = similarity; // Update highest similarity if boosted
             bestMatch = { choiceData: choice, index: index, similarity: similarity };
         }
         // --- End Keyword Matching Boost ---


    });

    if (bestMatch) {
        console.log(`[ChoiceSpeak DEBUG] Best match: "${stripHtml(bestMatch.choiceData.text)}" (Index: ${bestMatch.index}, Sim: ${bestMatch.similarity.toFixed(2)})`);
    } else {
        console.log("[ChoiceSpeak DEBUG] No suitable choice match found.");
    }
    return bestMatch;
}


// --- Main Game Flow Functions ---

// ----------  TOOLTIP  ----------------------------------------------------
// ----------  TOOLTIP  +  TTS‚Äëspeaker  ------------------------------------
// ----------  TOOLTIP  +  TTS‚Äëspeaker  ------------------------------------
(function () {
      const tip = document.createElement("div");
      tip.id = "translation-tooltip";
      document.body.appendChild(tip);

      const cacheTr = Object.create(null);
      const cacheAu = Object.create(null);
      let hideTimer = null;

      async function translateENtoUA(en) {
        if (cacheTr[en]) return cacheTr[en];
        const url =
          "https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=uk&dt=t&q=" +
          encodeURIComponent(en);
        try {
          const data = await fetch(url).then((r) => r.json());
          const ua = (data?.[0] || []).map((ch) => ch[0]).join(" ") || "‚Äî";
          cacheTr[en] = ua;
          return ua;
        } catch (e) {
          console.warn("[translate]", e);
          return "‚Äî";
        }
      }

      async function playTTS(text, lang = "en") {
        const key = text.slice(0, 190);
        if (cacheAu[key]) {
          cacheAu[key].currentTime = 0;
          cacheAu[key].play();
          return;
        }
        const url =
          "https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&tl=" +
          lang +
          "&q=" +
          encodeURIComponent(key);
        try {
          const blob = await fetch(url).then((r) => r.blob());
          const audio = new Audio(URL.createObjectURL(blob));
          cacheAu[key] = audio;
          await audio.play();
        } catch (e) {
          if ("speechSynthesis" in window) {
            const u = new SpeechSynthesisUtterance(text);
            u.lang = lang;
            speechSynthesis.speak(u);
          }
        }
      }

      function positionAbove(target) {
        const r = target.getBoundingClientRect();
        tip.style.display = "block";
        tip.style.opacity = "0";
        tip.style.left = "0";
        tip.style.top = "0";
        tip.offsetHeight; // force paint to get tooltip size
        const top = Math.max(4, r.top - tip.offsetHeight - 6);
        const left = Math.max(
          4,
          Math.min(
            r.left + r.width / 2 - tip.offsetWidth / 2,
            window.innerWidth - tip.offsetWidth - 4
          )
        );
        tip.style.top = `${top}px`;
        tip.style.left = `${left}px`;
        tip.style.opacity = "1";
      }

      function showTip({ ua, en, target }) {
        clearTimeout(hideTimer);
        tip.innerHTML = `<span>${ua}</span> <span id="speak-btn" style="cursor:pointer;margin-left:.5rem;">üîä</span>`;
        tip.dataset.en = en;
        positionAbove(target);
      }

      function scheduleHide(ms = 200) {
        clearTimeout(hideTimer);
        hideTimer = setTimeout(() => (tip.style.display = "none"), ms);
      }

      /* Tooltip self‚Äëevents */
      tip.addEventListener("mouseenter", () => clearTimeout(hideTimer));
      tip.addEventListener("mouseleave", () => scheduleHide());
      tip.addEventListener("click", (e) => {
        if (e.target.id === "speak-btn") playTTS(tip.dataset.en);
      });
      // ‚Äî Mobile tap on speaker icon ‚Äî
      tip.addEventListener(
        "touchend",
        (e) => {
          if (e.target.id === "speak-btn") {
            e.preventDefault();
            e.stopPropagation();
            clearTimeout(hideTimer);
            playTTS(tip.dataset.en);
          }
        },
        { passive: false }
      );

      /* Main hover logic  ‚Äì use mouseenter/mouseleave (non‚Äëbubbling) */
      document.addEventListener(
        "mouseenter",
        async (ev) => {
          const el = ev.target.closest(".translatable-sentence");
          if (!el) return;
          const en = el.dataset.en;
          const ua = el.dataset.ua || (el.dataset.ua = await translateENtoUA(en));
          showTip({ ua, en, target: el });
        },
        true // capture phase to catch events before they hit children
      );

      document.addEventListener(
        "mouseleave",
        (ev) => {
          if (ev.target.closest(".translatable-sentence")) scheduleHide();
        },
        true
      );

      /* Mobile tap */
      document.addEventListener(
        "touchstart",
        async (e) => {
          const el = e.target.closest(".translatable-sentence");
          if (!el) {
            tip.style.display = "none";
            return;
          }
          const en = el.dataset.en;
          const ua = el.dataset.ua || (el.dataset.ua = await translateENtoUA(en));
          showTip({ ua, en, target: el });
          scheduleHide(2500);
        },
        { passive: true }
      );
    })();



/** Displays the specified scene and prepares interactions */
function displayScene(sceneId) {
    console.log(`[Game Flow] Displaying scene: ${sceneId}`);
    const sceneData = gameData[sceneId];

    // Reset state variables for the new scene
    currentChoices = [];
    isMemoryCheckPhase = false;
    isChoiceSpeakingPhase = false;
    memoryCheckPassed = false;
    originalEnglishTextForMemoryCheck = "";
    formattedUkrainianTextForMemoryCheck = "";

    // Stop any ongoing interactions
    if (synth?.speaking) synth.cancel();
    if (recognition && isListening) {
        try { recognition.abort(); } catch (e) {}
        isListening = false;
    }
    sceneTextEl.classList.remove('speaking', 'memory-recall-active');

    if (!sceneData) {
        console.error(`[Game Flow] Invalid sceneId: ${sceneId}.`);
        sceneTextEl.innerHTML = formatText("Error: Scene data not found. Please restart.");
        choicesContainerEl.innerHTML = '';
        setChoicesVisibility(false);
        setVocabListVisibility(false);
        outcomeDisplayEl.innerHTML = '<div class="game-over">ERROR</div>';
        addRestartButton();
        updateVoiceButtonUI();
        return;
    }

    // Process Scene Text (EN and UA)
    const englishText = (typeof sceneData.text === 'object' && sceneData.text.en) ? sceneData.text.en : sceneData.text;
    const ukrainianText = (typeof sceneData.text === 'object' && sceneData.text.ua) ? sceneData.text.ua : null;
    let sceneDisplayText = englishText || `Scene "${sceneId}" has no English text.`;
    let outcomeMessage = '';
    const gameOverMatch = sceneDisplayText.match(/<span class='game-over'>(.*?)<\/span>/i);
    const gameSuccessMatch = sceneDisplayText.match(/<span class='game-success'>(.*?)<\/span>/i);
    const isEndScene = !!(gameOverMatch || gameSuccessMatch);

    if (gameOverMatch) {
        outcomeMessage = `<div class="game-over">${gameOverMatch[1]}</div>`;
        sceneDisplayText = sceneDisplayText.replace(gameOverMatch[0], '').trim();
    } else if (gameSuccessMatch) {
        outcomeMessage = `<div class="game-success">${gameSuccessMatch[1]}</div>`;
        sceneDisplayText = sceneDisplayText.replace(gameSuccessMatch[0], '').trim();
    }

    // ---- create EN sentence wrappers *before* saving for later ----------------
    originalEnglishTextForMemoryCheck = wrapSentencesWithTranslation(
            sceneDisplayText,          // raw EN
            ukrainianText || ''        // provided UA (may be empty)
    );
    // ---------------------------------------------------------------------------

    if (ukrainianText){
        formattedUkrainianTextForMemoryCheck = formatText(ukrainianText);
    }

    const plainEnglishText = stripHtml(originalEnglishTextForMemoryCheck);

    // Initial UI Update
    sceneTextEl.innerHTML = originalEnglishTextForMemoryCheck;
    outcomeDisplayEl.innerHTML = outcomeMessage;
    voiceStatusEl.textContent = '';
    voiceStatusEl.className = 'text-info';
    choicesContainerEl.innerHTML = ''; // Clear before preparing

    updateVocabList(plainEnglishText);
    setVocabListVisibility(true);

    // *** Prepare choice elements (container starts hidden) ***
    // Use prepareAndDisplayChoices which now creates the elements
    if (sceneData.choices?.length > 0) {
        prepareAndDisplayChoices(sceneData);
    } else if (isEndScene) {
        addRestartButton(); // Ensures restart button is added if no choices defined
    }
    // Ensure choices container starts hidden for the new scene
    setChoicesVisibility(false);

    updateVoiceButtonUI(); // Set initial button state

    // --- Speak English Text & Setup Next Interaction Phase ---
    console.log("[Game Flow] Calling speakText for the scene.");
    speakText(plainEnglishText, 'en-GB', () => {
        console.log("[Game Flow] speakText callback executed.");
        const needsMemoryCheck = !!formattedUkrainianTextForMemoryCheck && !isEndScene;
        console.log(`[Game Flow] speakText callback: needsMemoryCheck = ${needsMemoryCheck}, isEndScene = ${isEndScene}`);

        if (needsMemoryCheck) {
            console.log("[Game Flow] Setting up Memory Check phase.");
            isMemoryCheckPhase = true;
            isChoiceSpeakingPhase = false;
            memoryCheckPassed = false;
            voiceStatusEl.textContent = "Listen carefully to the text above.";
        } else {
            console.log("[Game Flow] Skipping Memory Check or is End Scene.");
            isMemoryCheckPhase = false;
            isChoiceSpeakingPhase = !isEndScene;
            memoryCheckPassed = true;

            if (!isEndScene) {
                console.log("[Game Flow] Setting up Choice Speaking phase (no memory check).");
                voiceStatusEl.textContent = "Speak your desired choice.";
                setChoicesVisibility(false); // Keep choices hidden if skipping memory check too
            } else {
                console.log("[Game Flow] End scene reached. No further voice action.");
                voiceStatusEl.textContent = "Game finished.";
                // Make sure restart button is visible if added
                 if (document.getElementById('restart-button') || document.getElementById('dynamic-restart-button')) {
                     setChoicesVisibility(true);
                 }
            }
        }
        updateVoiceButtonUI(); // Update button state AFTER determining phase
    });
}

/** Populates currentChoices array but doesn't create buttons */
function prepareAndDisplayChoices(sceneData) {
    choicesContainerEl.innerHTML = ''; // Clear previous
    currentChoices = []; // Reset choices array

    if (sceneData.choices?.length > 0) {
        currentChoices = sceneData.choices.map(choice => ({
            text: choice.text,
            nextScene: choice.nextScene
        }));
        console.log(`[Game Flow] Prepared ${currentChoices.length} choices for matching.`);

        // Create visual elements (these will be in the container, initially hidden)
        currentChoices.forEach(choice => {
            const element = document.createElement('div'); // Use div instead of button for non-clickable choices
            // Style like a button, but use 'default' cursor and maybe slightly faded
            element.className = `block w-full p-3 mb-3 border-none bg-accent text-white text-left rounded text-base transition-colors duration-200 ease-in-out focus:outline-none opacity-90 cursor-default`; // Adjusted style
            element.innerHTML = formatText(choice.text); // Display formatted text
            element.innerHTML = wrapSentencesWithTranslation(
      choice.text,   // EN
      ''             // UA –¥–ª—è –∫–Ω–æ–ø–æ–∫ –Ω–µ–º–∞
);


            // Special handling ONLY if a choice IS "Restart Game"
            if (choice.text === "Restart Game") {
                 element.remove(); // Remove the div we just made for restart
                 const restartButton = document.createElement('button'); // Create a real button for restart
                restartButton.id = "restart-button"; // Use specific ID if needed
                restartButton.className = `block w-fit mx-auto p-3 mt-4 border-none bg-danger text-white cursor-pointer rounded text-base transition-colors duration-200 ease-in-out hover:bg-danger-dark focus:outline-none focus:ring-2 focus:ring-danger-dark focus:ring-opacity-50`; // Restart button styles
                restartButton.textContent = choice.text;
                restartButton.disabled = false; // Ensure restart is clickable
                restartButton.onclick = () => handleChoice(choice); // Add click handler ONLY for restart
                 choicesContainerEl.appendChild(restartButton); // Add the button
            } else {
                 choicesContainerEl.appendChild(element); // Add the non-clickable div
            }
        });

    } else {
        console.warn("[Game Flow] prepareAndDisplayChoices called, but sceneData has no choices.");
    }
     // Ensure container itself starts hidden (visibility controlled elsewhere)
     setChoicesVisibility(false);
}


/** Adds a visible Restart Game button */
function addRestartButton() {
     // Check if a restart button from gameData choices already exists
     let existingRestartButton = null;
     choicesContainerEl.querySelectorAll('button').forEach(btn => {
         if (btn.id === 'restart-button') {
             existingRestartButton = btn;
         }
     });

     if (existingRestartButton) {
         console.log("[Game Flow] Restart button already exists from choices.");
         setChoicesVisibility(true); // Make sure container is visible if restart is the choice
         existingRestartButton.disabled = false; // Ensure it's clickable
         return;
     }

     // If no restart button from choices, create one dynamically
    if (document.getElementById('dynamic-restart-button')) return; // Avoid adding duplicates
    if (synth?.speaking) synth.cancel();

    const restartChoice = { text: "Restart Game", nextScene: 'start' };
    const button = document.createElement('button');
    // Use specific ID for dynamically added button
    button.id = "dynamic-restart-button";
    // Apply restart button styling
    button.className = `block w-fit mx-auto p-3 mt-4 border-none bg-danger text-white cursor-pointer rounded text-base transition-colors duration-200 ease-in-out hover:bg-danger-dark focus:outline-none focus:ring-2 focus:ring-danger-dark focus:ring-opacity-50`;
    button.textContent = restartChoice.text;
    button.onclick = () => handleChoice(restartChoice);
    button.disabled = false; // Make clickable immediately

    // Append to outcome display or choices container? Let's use choices for consistency
    choicesContainerEl.appendChild(button);
    setChoicesVisibility(true); // Make container visible for the restart button
    console.log("[Game Flow] Added dynamic restart button.");
}


/** Handles moving to the next scene */
function handleChoice(choiceData) {
     console.log(`[Game Flow] Handling choice: "${choiceData.text}" -> ${choiceData.nextScene}`);

     // Stop interactions
     if (synth?.speaking) synth.cancel();
     if (recognition && isListening) {
         try { recognition.abort(); } catch(e) {}
         isListening = false;
     }
     sceneTextEl.classList.remove('speaking', 'memory-recall-active');

     if (!choiceData?.nextScene) {
         console.error("[Game Flow] Invalid choice data (missing nextScene):", choiceData);
         sceneTextEl.innerHTML = formatText("Error: Invalid choice selected. Please restart.");
         choicesContainerEl.innerHTML = '';

         setChoicesVisibility(false);
         setVocabListVisibility(false);
         outcomeDisplayEl.innerHTML = '<div class="game-over">ERROR</div>';
         addRestartButton();
         updateVoiceButtonUI(); // Disable voice button
         return;
     }

     // Proceed to the next scene
     console.log(`[Game Flow] Moving to scene: ${choiceData.nextScene}`);
     currentSceneId = choiceData.nextScene;
     // Reset phases before displaying next scene
     isMemoryCheckPhase = false;
     isChoiceSpeakingPhase = false;
     displayScene(currentSceneId);
}
// --- End of Chunk 2 ---
// --- Start of Chunk 3 ---
// (Continuing script from Chunk 2)

// --- Event Listener Setup ---

/** Handles clicks on the main voice action button */
function handleVoiceButtonClick() {
    console.log(`[Voice Button] Clicked. MemoryPhase: ${isMemoryCheckPhase}, ChoicePhase: ${isChoiceSpeakingPhase}, Listening: ${isListening}`);

    if (!recognition) {
        console.error("[Voice Button] Recognition not initialized.");
        voiceStatusEl.textContent = "Voice input system error.";
        voiceStatusEl.className = 'text-danger';
        return;
    }
    if (!micPermissionGranted) {
        console.warn("[Voice Button] Mic permission not granted.");
        voiceStatusEl.textContent = "Microphone access needed.";
        voiceStatusEl.className = 'text-danger';
        // requestMicPermission(); // Optionally re-request?
        return;
    }

    if (isListening) {
        console.log("[Voice Button] Currently listening, stopping recognition.");
        try {
            recognition.stop();
        } catch (e) {
            console.warn("[Voice Button] Error stopping recognition:", e);
        }
        // onend will handle UI update
    } else {
        // If not listening, start based on phase
        if (isMemoryCheckPhase) {
            console.log("[Voice Button] Starting memory recall recognition.");
            // Hide English text, show Ukrainian/Placeholder
            if (formattedUkrainianTextForMemoryCheck) {
                sceneTextEl.innerHTML = formattedUkrainianTextForMemoryCheck;
            } else {
                sceneTextEl.innerHTML = "<p class='text-highlight p-2 text-center'>Translation not available.<br/>Recall the English text.</p>";
            }
            sceneTextEl.classList.add('memory-recall-active');
            setVocabListVisibility(false); // Hide vocab during recall attempt
            setChoicesVisibility(false); // Ensure choices definitely hidden

            try {
                recognition.lang = 'en-US'; // Ensure English for recall
                recognition.start();
            } catch (e) {
                console.error("[Voice Button] Error starting memory recognition:", e);
                // Restore UI if start fails
                sceneTextEl.innerHTML = originalEnglishTextForMemoryCheck;
                sceneTextEl.classList.remove('memory-recall-active');
                setVocabListVisibility(true);
                voiceStatusEl.textContent = "Error starting voice input.";
                voiceStatusEl.className = 'text-danger';
                isListening = false;
                updateVoiceButtonUI();
            }
        } else if (isChoiceSpeakingPhase) {
            console.log("[Voice Button] Starting choice speaking recognition.");

            // *** HIDE CHOICES BEFORE LISTENING FOR CHOICE ***
            setChoicesVisibility(false);
            voiceStatusEl.textContent = "Listening for your choice..."; // Update status prompt

            try {
                recognition.lang = 'en-US'; // Ensure English for choice
                recognition.start();
            } catch (e) {
                console.error("[Voice Button] Error starting choice recognition:", e);
                voiceStatusEl.textContent = "Error starting voice input.";
                voiceStatusEl.className = 'text-danger';
                // Show choices again if listening fails? Or keep hidden? Let's keep hidden.
                // setChoicesVisibility(true);
                isListening = false;
                updateVoiceButtonUI();
            }
        } else {
            console.warn("[Voice Button] Clicked in unexpected state (not memory or choice phase).");
            // Maybe it's an end scene? Button should be disabled.
        }
    }
}

// --- Replace existing addRestartButton function ---
function addRestartButton() {
    // Check if a restart button (dynamic or from choices) already exists
    if (document.getElementById('restart-button') || document.getElementById('dynamic-restart-button')) {
         console.log("[Game Flow] Restart button already exists.");
         // Ensure container is visible if restart button is present
         setChoicesVisibility(true);
         // Ensure the button itself is enabled (might have been disabled)
         const btn = document.getElementById('restart-button') || document.getElementById('dynamic-restart-button');
         if(btn) btn.disabled = false;
         return;
    }

    // If no restart button exists, create one dynamically
    if (synth?.speaking) synth.cancel();

    const restartChoice = { text: "Restart Game", nextScene: 'start' };
    const button = document.createElement('button');
    button.id = "dynamic-restart-button"; // Use specific ID
    button.className = `block w-fit mx-auto p-3 mt-4 border-none bg-danger text-white cursor-pointer rounded text-base transition-colors duration-200 ease-in-out hover:bg-danger-dark focus:outline-none focus:ring-2 focus:ring-danger-dark focus:ring-opacity-50`;
    button.textContent = restartChoice.text;
    button.onclick = () => handleChoice(restartChoice);
    button.disabled = false; // Make clickable immediately

    choicesContainerEl.appendChild(button);
    // *** MAKE SURE CONTAINER IS VISIBLE FOR RESTART ***
    setChoicesVisibility(true);
    console.log("[Game Flow] Added dynamic restart button.");
}



/** Listener for the Start Challenge / Enable Audio button */
startChallengeBtn.addEventListener('click', () => {
    console.log("[DEBUG] Start Challenge button clicked.");

    // *** Disable button immediately to prevent rapid clicks / re-entry ***
    startChallengeBtn.disabled = true;
    console.log("[DEBUG] Start Challenge Button DISABLED.");

    // Check ttsUnlocked status AFTER disabling
    console.log(`[DEBUG] Checking ttsUnlocked status: ${ttsUnlocked}`);
    if (ttsUnlocked) {
        console.log("[DEBUG] ttsUnlocked is TRUE. Audio already enabled. Ensuring correct final state.");
        // Keep button disabled as audio is already enabled
        startChallengeBtn.textContent = 'Listen carefully ‚úÖ'; // Ensure text is correct
        startChallengeBtn.classList.remove('bg-accent', 'hover:bg-accent-dark', 'bg-danger'); // Clean up styles
        startChallengeBtn.classList.add('audio-enabled');
        return; // Exit, already handled
    }

    console.log("[DEBUG] ttsUnlocked is FALSE. Proceeding...");

    console.log("[DEBUG] Checking synth support...");
    if (!synth) {
        console.error("[DEBUG] Speech synthesis NOT SUPPORTED.");
        alert("Speech synthesis not supported by this browser.");
        startChallengeBtn.textContent = 'Audio Not Supported';
        // Button remains disabled
        return;
    }

    console.log("[DEBUG] Synth support confirmed. Attempting to unlock TTS...");
    startChallengeBtn.textContent = 'Enabling Audio...'; // Provide feedback

    const utterance = new SpeechSynthesisUtterance("Listen carefully.");
    utterance.volume = 0.01; // Keep it quiet/fast
    utterance.rate = 1.0;

    let eventFired = false; // Flag to track if onend/onerror occurs
    let fallbackTimer = null; // Timer handle

    utterance.onstart = () => {
        console.log("[DEBUG] TTS utterance started successfully.");
        // Optional: Clear the fallback timer if onstart fires,
        // as it means the synth engine is responding.
        // if (fallbackTimer) clearTimeout(fallbackTimer);
    };

    utterance.onend = () => {
        console.log("[DEBUG] TTS utterance finished (onend). Setting ttsUnlocked=true.");
        if (fallbackTimer) clearTimeout(fallbackTimer); // Clear timeout if event fires
        eventFired = true;
        if (!ttsUnlocked) { // Avoid running startGame twice if timeout also fired
            ttsUnlocked = true;
            startChallengeBtn.textContent = 'Listen carefully ‚úÖ';
            startChallengeBtn.classList.remove('bg-accent', 'hover:bg-accent-dark', 'bg-danger');
            startChallengeBtn.classList.add('audio-enabled');
            // Button remains disabled (as intended after success)

            console.log("[DEBUG] TTS unlocked via onend. Calling startGame()...");
            setTimeout(startGame, 50); // Short delay after state change
        }
    };

    utterance.onerror = (e) => {
        console.error("[DEBUG] TTS utterance ONSYNTH ERROR:", e.error, e);
         if (fallbackTimer) clearTimeout(fallbackTimer); // Clear timeout if event fires
        eventFired = true;
        if (!ttsUnlocked) { // Avoid running startGame twice
            alert(`Failed to enable audio: ${e.error}. Sound may not work. Trying to continue anyway...`);
            ttsUnlocked = true; // Attempt to proceed despite error
            startChallengeBtn.textContent = 'Audio Failed - Continuing';
            startChallengeBtn.classList.remove('bg-accent', 'hover:bg-accent-dark');
            startChallengeBtn.classList.add('audio-enabled', 'bg-danger');
            // Button remains disabled

            console.log("[DEBUG] TTS unlock failed via onerror. Attempting to call startGame() anyway...");
            setTimeout(startGame, 50);
        }
    };

    // --- Fallback Timer ---
    // If neither onend nor onerror has fired after a reasonable time,
    // assume the TTS unlock is stuck or failed silently. Force proceed.
    fallbackTimer = setTimeout(() => {
        console.log("[DEBUG] Fallback timer executing check...");
        if (!eventFired && !ttsUnlocked) { // Check if events fired or state changed
            console.warn("[DEBUG] TTS unlock fallback: Neither onend nor onerror fired after 2 seconds. Assuming failure but proceeding.");
            alert("Audio enablement timed out. Sound may not work. Trying to continue anyway...");
            ttsUnlocked = true; // Force unlock state
            startChallengeBtn.textContent = 'Audio Timeout - Continuing';
            startChallengeBtn.classList.remove('bg-accent', 'hover:bg-accent-dark');
            startChallengeBtn.classList.add('audio-enabled', 'bg-danger');
             // Button remains disabled

            console.log("[DEBUG] TTS unlock timed out. Attempting to call startGame()...");
            // No need for another setTimeout here, as we are already in one
            startGame();
        } else {
             console.log("[DEBUG] Fallback timer: Event already fired or TTS unlocked. No action needed.");
        }
    }, 2000); // 2 second timeout

    // --- Attempt to Speak ---
    try {
        console.log("[DEBUG] Calling synth.speak(utterance)...");
        // Clear any previous synth queue just in case
        if (synth.speaking || synth.pending) {
            console.warn("[DEBUG] Cancelling existing speech before new unlock attempt.");
            synth.cancel();
        }
        synth.speak(utterance);
        console.log("[DEBUG] synth.speak() called without immediate error.");

    } catch (e) {
        console.error("[DEBUG] Error thrown immediately by synth.speak():", e);
        if (fallbackTimer) clearTimeout(fallbackTimer); // Clear timeout on immediate error
        eventFired = true; // Error is an event
        if (!ttsUnlocked) { // Avoid running startGame twice
            alert("Could not initiate audio enablement due to an immediate error. Trying to continue anyway...");
            ttsUnlocked = true; // Attempt to proceed
            startChallengeBtn.textContent = 'Audio Error - Continuing';
            startChallengeBtn.classList.remove('bg-accent', 'hover:bg-accent-dark');
            startChallengeBtn.classList.add('audio-enabled', 'bg-danger');
            // Button remains disabled

            console.log("[DEBUG] synth.speak() threw error. Attempting to call startGame() anyway...");
            setTimeout(startGame, 50);
        }
    }
});


// --- Game Initialization ---

/** Requests microphone permission */
async function requestMicPermission() {
     if (!SpeechRecognitionAPI) {
         console.log("[Init] Speech Rec not supported, skipping mic request.");
          micPermissionGranted = false;
         return false;
     }
     if (micPermissionGranted === true) {
         console.log("[Init] Mic permission already granted.");
         return true;
     }
     if (micPermissionGranted === false) {
         console.log("[Init] Mic permission previously denied.");
         // Don't re-prompt if explicitly denied previously, user must change in settings
         return false;
     }

     // If status is null (unknown)
     try {
         console.log("[Init] Requesting microphone permission...");
         voiceStatusEl.textContent = "Requesting microphone access...";
         voiceStatusEl.className = 'text-info';
         const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
         console.log("[Init] Microphone permission GRANTED.");
         micPermissionGranted = true;
         stream.getTracks().forEach(track => track.stop()); // Release mic indicator
         voiceStatusEl.textContent = ""; // Clear prompt
         return true;
     } catch (err) {
         console.error("[Init] Microphone permission DENIED or error:", err.name, err.message);
         micPermissionGranted = false;
         voiceStatusEl.textContent = "Microphone access denied. Voice input disabled.";
         voiceStatusEl.className = 'text-danger';
         return false;
     }
}

/** Initializes the game state and starts the first scene */
async function startGame() {
     console.log("[Init] startGame() called. TTS Unlocked:", ttsUnlocked);

     // --- Wait for TTS Unlock ---
     if (!ttsUnlocked) {
         console.log("[Init] TTS not unlocked. Displaying 'Start Challenge' prompt.");
         sceneTextEl.innerHTML = `<div class='p-4 text-center text-lg text-highlight'>Click the 'Start the challenge' button above to begin.</div>`;
         choicesContainerEl.innerHTML = '';
         setChoicesVisibility(false);
         setVocabListVisibility(false);
         outcomeDisplayEl.innerHTML = '';
         voiceButton.disabled = true; // Voice button disabled initially
         updateVoiceButtonUI();
         startChallengeBtn.disabled = false; // Ensure start button is clickable
         startChallengeBtn.textContent = 'Start the challenge üöÄ';
         startChallengeBtn.classList.remove('audio-enabled');
         startChallengeBtn.classList.add('bg-accent', 'hover:bg-accent-dark');
         return; // Wait for button click
     }

    // --- TTS Unlocked - Proceed ---
    console.log("[Init] TTS unlocked. Initializing game elements.");
    currentSceneId = 'start';
    isMemoryCheckPhase = false;
    isChoiceSpeakingPhase = false;
    memoryCheckPassed = false;

     // Ensure voices are loaded before selecting
     if (synth.getVoices().length === 0 && voicesLoaded === false) {
         console.log("[Init] Waiting for voices to load...");
         await new Promise(resolve => {
             if (voicesLoaded) resolve(); // Already loaded by the time we check
             else synth.addEventListener('voiceschanged', resolve, { once: true });
         });
         console.log("[Init] Voices loaded.");
     }
     selectedVoice = getBestVoice();
     console.log("[Init] Selected TTS voice:", selectedVoice ? selectedVoice.name : "default");

     // Initialize Speech Recognition (checks support internally)
     initializeSpeechRecognition();

     // Request Microphone Permission (only if needed and possible)
     await requestMicPermission();

     // Attach the single click listener to the voice button
     voiceButton.removeEventListener('click', handleVoiceButtonClick); // Remove old first
     voiceButton.addEventListener('click', handleVoiceButtonClick);
     console.log("[Init] Voice button click listener attached.");


     // Final update to button UI after permissions etc.
     updateVoiceButtonUI();

     // Display the First Scene
     console.log(`[Init] Initialization complete. Displaying first scene: '${currentSceneId}'.`);
     displayScene(currentSceneId);
}

// =====================================================================
// ‚ù∑  Observe DOM changes so any new English text becomes translatable
// =====================================================================
// --------------- –≤–∫–ª—é—á–∏—Ç–∏ –ø—ñ—Å–ª—è displayScene() -----------------
const root = document.getElementById('game-container');
makeTextNodesTranslatable(root);   // —Å—Ç–∞—Ä—Ç–æ–≤–∞ –æ–±–≥–æ—Ä—Ç–∫–∞

const obs = new MutationObserver(muts=>{
    muts.forEach(m=>{
        m.addedNodes.forEach(n=>{
            if(n.nodeType===Node.ELEMENT_NODE) makeTextNodesTranslatable(n);
        });
    });
});
obs.observe(root,{childList:true,subtree:true});


// --- Initial Page Load ---
document.addEventListener('DOMContentLoaded', () => {
    console.log("[Init] DOMContentLoaded. Calling startGame() for initial setup.");
    startGame(); // Shows prompt or starts game if audio already enabled (e.g., refresh)
});

// --- End of Chunk 3 ---
</script>
</body>
</html>